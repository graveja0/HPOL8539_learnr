<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />



<meta name="progressive" content="true" />
<meta name="allow-skip" content="true" />
<meta name="learnr-version-prerender" content="0.10.5.9000" />

<title>Simulation as a Guide for Study Design and Inference</title>

<!-- header-includes START -->
<!-- HEAD_CONTENT -->
<!-- header-includes END -->
<!-- HEAD_CONTENT -->

<!-- highlightjs -->
<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>


<!-- taken from https://github.com/rstudio/rmarkdown/blob/de8a9c38618903627ca509f5401d50a0876079f7/inst/rmd/h/default.html#L293-L343 -->
<!-- tabsets -->
<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>
<!-- end tabsets -->

<link rel="stylesheet" href="css/style.css" type="text/css" />

</head>

<body>
<a class='sr-only sr-only-focusable visually-hidden-focusable' href='#learnr-tutorial-content'>Skip to Tutorial Content</a>



<div class="pageContent band">
<main class="bandContent page">

<article class="topics" id="learnr-tutorial-content">

<div id="section-introduction" class="section level2">
<h2>Introduction</h2>
<p>The goal of this exercise is to familiarize you with how to use
simulation to help guide your choice of estimators and inference for
policy and program evaluation.</p>
</div>
<div id="section-exercise-1-simulating-from-a-distribution"
class="section level2">
<h2>Exercise 1: Simulating From a Distribution</h2>
<p>Our first objective is to parameterize and execute the simplest
possible simulation:</p>
<ul>
<li>Sample size is <span class="math inline">\(N=1,000\)</span>
individuals indexed by <span class="math inline">\(i\)</span>.</li>
<li>The simulated variable <span class="math inline">\(X_i\)</span> is
normally distributed with mean 2 and standard deviation 0.5, i.e., <span
class="math inline">\(X_i \sim N(2,0.5)\)</span>.</li>
</ul>
<p>We will proceed along four steps:</p>
<ol style="list-style-type: decimal">
<li>Parameterize the problem.</li>
<li>Define a data generation function.</li>
<li>Define and apply an estimation function.</li>
<li>Define and apply a discriminator function.</li>
</ol>
<div id="section-step-1-parameterize-the-problem"
class="section level3">
<h3>Step 1: Parameterize the Problem</h3>
<div class="tutorial-exercise" data-label="simple1" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="8">
<pre class="text"><code>params =
  list(
    N = 1000, 
    mean_x_i = 2,
    sd_x_i = 0.5
  )
params</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
<div id="section-step-2-define-a-data-generation-process"
class="section level3">
<h3>Step 2: Define a Data Generation Process</h3>
<p>Our next objective is to write a very basic data generation function
that takes as its input the parameter list created above, and spits out
the simulated value of <span class="math inline">\(X_i\)</span> based on
those parameters.</p>
<p>Note that the <code>rnorm()</code> command is R’s way of simulating
from a normal distribution.</p>
<p>Go ahead and execute the <code>dgp()</code> function with the
supplied parameters below.</p>
<div class="tutorial-exercise" data-label="simple1_dgp"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="10">
<pre class="text"><code># Simulate a data generation process (dgp)
dgp = function(params) {
  with(params,{
    x_i = rnorm(N, mean_x_i, sd_x_i)
    return(x_i)
  })
}

params %&gt;% 
  dgp()</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div id="section-structure-output-as-a-data-frame"
class="section level4">
<h4>Structure Output as a Data Frame</h4>
<p>You’ll notice that the output is rather …. messy. Let’s restructure
our data generation code so that it outputs as a data frame / tibble,
rather than a simple vector.</p>
<div class="tutorial-exercise" data-label="simple1_dgp3"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="12">
<pre class="text"><code>dgp_df =function(params) {
  with(params,{
    df =
      tibble(
        x_i = rnorm(N, mean_x_i, sd_x_i)
      )
    return(df)
  })
}

params %&gt;% dgp_df()</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
</div>
<div id="section-step-3-define-and-apply-an-estimation-function"
class="section level3">
<h3>Step 3: Define and Apply an Estimation Function</h3>
<p>Now lets suppose we want to estimate the expected value (mean) of
<span class="math inline">\(X_i\)</span>. For an estimator this basic we
could, of course, simply summarize directly. However, to allow for more
complex estimators we’ll define it in a function.</p>
<p>Below we define a function that takes as its input a data frame
(<code>df</code>). We then take the mean of <code>x_i</code>:</p>
<div class="tutorial-exercise" data-label="simple1_est1"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="11">
<pre class="text"><code>estimator_fn =function(df) {
  out =
    df %&gt;% 
      summarise(mean_x_i = mean(x_i))
  return(out)
}

params %&gt;% 
  dgp_df() %&gt;% 
  estimator_fn()</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<p>Next, suppose we want to adapt our estimator. Instead of the mean, we
want to estimate the mean plus 1. We can simply adapt our estimator
function accordingly:</p>
<div class="tutorial-exercise" data-label="simple1_est2"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="11">
<pre class="text"><code>estimator_fn_alt =function(df) {
  out =
    df %&gt;% 
      summarise(mean_x_i = mean(x_i) + 1)
  return(out)
}

params %&gt;% 
  dgp_df() %&gt;% 
  estimator_fn_alt()</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<p>We’ll skip step 4 (“Define and Apply a Discriminator Function”) for
now and next adapt and expand the above for an outcome (<span
class="math inline">\(Y_i\)</span>) that is a function of <span
class="math inline">\(X_i\)</span> and a treatment effect.</p>
</div>
</div>
<div id="section-exercise-2-basic-regression" class="section level2">
<h2>Exercise 2: Basic Regression</h2>
<p>Our next exercise will simulate an outcome (<span
class="math inline">\(Y_i\)</span>) based on a defined data generation
process. Let’s define the data generation process in terms of a binary
treatment indicator <span class="math inline">\(D_i\)</span>, a
continuous patient-level attribute (<span class="math inline">\(X_i \sim
N(2,0.5)\)</span>, as above) , and an idiosyncratic error term <span
class="math inline">\(\epsilon_i \sim N(0,1)\)</span>:</p>
<p><span class="math display">\[
\begin{aligned}
Y_i &amp;= \beta X_i + \tau D_i + \epsilon_i \\
&amp; = 1 \cdot X_i + 0.5 \cdot D_i + \epsilon_i
\end{aligned}
\]</span></p>
<p>In R, normally distributed variables are sampled using
<code>rnorm()</code>, while binary variables can be sampled using
<code>rbinom()</code>. Let’s suppose 50% of the sample is treated, in
expectation.</p>
<p>We will now re-parametrize and define a data generation function
based on the above:</p>
<div id="section-step-1-parameterize-the-problem-1"
class="section level3">
<h3>Step 1: Parameterize the Problem</h3>
<div class="tutorial-exercise" data-label="basicreg1_param"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="10">
<pre class="text"><code>params =list(
  N = 1000,
  mean_x_i = 2,
  sd_x_i = 0.5,
  pr_Tx = 0.5,
  beta = 1,
  tau = 0.5,
  sigma_sq_epsilon = 1
)

params </code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
<div id="section-step-2-define-a-data-generation-process-function"
class="section level3">
<h3>Step 2: Define a Data Generation Process Function</h3>
<div class="tutorial-exercise" data-label="basicreg1_dgp"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="16">
<pre class="text"><code>dgp_df =function(params) {
  with(params,{
    df =
      tibble(
        x_i = rnorm(N, mean_x_i, sd_x_i),
        d_i = rbinom(N, size = 1, prob = pr_Tx),
        epsilon_i = rnorm(N, mean = 0, sd = sigma_sq_epsilon)
      ) %&gt;% 
      mutate(y_i = beta * x_i + tau * d_i + epsilon_i)
    return(df)
  })
}

params %&gt;% 
  dgp_df()</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
<div id="section-step-3-define-and-apply-an-estimation-function-1"
class="section level3">
<h3>Step 3: Define and Apply an Estimation Function</h3>
<p>Next, suppose we are interested in estimating <span
class="math inline">\(\tau\)</span>, the coefficient on being in the
treatment group. In that case there is a relatively straightforward
mapping between our <strong>quantity of interest</strong>, i.e., <span
class="math inline">\(\tau\)</span> and what we can obtain directly from
an ordinary least squares (OLS) regression (i.e., the
<strong>estimator</strong>) of <span class="math inline">\(Y_i\)</span>
on <span class="math inline">\(X_i\)</span> and <span
class="math inline">\(D_i\)</span>. In R, an OLS regression can be fit
using the command <code>lm()</code>.</p>
<div class="tutorial-exercise" data-label="basicreg1_est"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="15">
<pre class="text"><code>estimator_fn = function(df) {
  out =
    df %&gt;% 
      lm(y_i ~ x_i + d_i, data = .)
  return(out)
}

fit1 = 
  params %&gt;% # Step 1: Parameterize the problem
    dgp_df() %&gt;%  # Step 2: Define the data generation process
    estimator_fn() # Step 3: Apply the estimator
fit1 </code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
<div id="section-step-4-define-and-apply-a-discriminator-function"
class="section level3">
<h3>Step 4: Define and Apply a Discriminator Function</h3>
<p>Above, we noted that the parameter of interest is <span
class="math inline">\(\tau\)</span>, the coefficient on the binary
treatment indicator. We’ll now define a “discriminator” function that
plucks out this parameter of interest.</p>
<p>Note that this function takes as its input a fitted estimation
object, not a data frame.</p>
<div class="tutorial-exercise" data-label="basicreg1_disc1"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="15">
<pre class="text"><code>disc_fn = function(fit) {
  fit_ =broom::tidy(fit)   # This cleans up the fitted regression object
  out =fit_ %&gt;% 
    filter(term==&quot;d_i&quot;) %&gt;% 
    pull(estimate)
  
  return(out)
}

# First, take a look at what tidy() does. 
broom::tidy(fit1)

# Next, apply the discriminator function to the estimated regression
disc_fn(fit1)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<p>We can now pull everything together into one code pipe to complete
the full four-step process. Each time we run it, we simulate a new
dataset based on the defined parameters, estimate <span
class="math inline">\(\tau\)</span>, then pull out our estimate of <span
class="math inline">\(\tau\)</span> from the OLS regression:</p>
<div class="tutorial-exercise" data-label="basicreg1_disc2"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="18">
<pre class="text"><code># Run it once...
params %&gt;% 
  dgp_df() %&gt;% 
    estimator_fn() %&gt;% 
      disc_fn()
      
# Run it again...
params %&gt;% 
  dgp_df() %&gt;% 
    estimator_fn() %&gt;% 
      disc_fn()
      
# Run it a third time!    
params %&gt;% 
  dgp_df() %&gt;% 
    estimator_fn() %&gt;% 
      disc_fn()</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
</div>
<div id="section-exercise-3-monte-carlo-simulation"
class="section level2">
<h2>Exercise 3: Monte Carlo Simulation</h2>
<p>We now have the tools and functions in place to simulate, estimate,
and draw our parameter of interest. However, what if we want to
understand properties of our estimator? That is, is it unbiased (i.e.,
estimate the underlying “truth” accurately)? Alternatively, we might be
concerned about issues of inference. For example, if we estimate a basic
linear regression model without accounting for heteroskedasticity, will
we have a false discovery rate of 5%?</p>
<p>To answer these types of questions it is often useful to conduct a
full monte carlo simulation. The basic steps are simple:</p>
<ol style="list-style-type: decimal">
<li>Generate the data, estimate the model, and pull out the parameter of
interest <span class="math inline">\(M\)</span> times.</li>
<li>Look at the distribution of <span class="math inline">\(M\)</span>
parameters.</li>
</ol>
<div id="section-sampling-distribution-of-the-ols-estimator"
class="section level3">
<h3>Sampling Distribution of the OLS estimator</h3>
<div class="tutorial-exercise" data-label="basicreg1_mcgen"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="20">
<pre class="text"><code>M = 1000

res_sampdist &lt;- c() # we start with a basic (empty) object. 

# Loop over the generation, estimation, discrimination process
# M times, each time storing the result
for (m in 1:M) {
  # We&#39;re just going to append the result on the end of the result opbject
  res_sampdist &lt;- 
    c(res_sampdist, 
      # You&#39;ve seen all this before ... 
      params %&gt;%
        dgp_df() %&gt;%
          estimator_fn() %&gt;%
            disc_fn()
  )
}
plot_sampling_distribution(res_sampdist,truth=params$tau)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
<div id="section-aside-loops-using-map" class="section level3">
<h3>Aside: Loops using <code>map()</code></h3>
<p>The loop structure above is totally fine to use, however it results
in rather clunky code. An option I highly recommend is the
<code>purrr</code> package in R, which simplifies loops into a single
command called <code>map()</code>.</p>
<p>The basic structure is that you supply <code>map()</code> with a
vector of things to “loop” over, which in this case is just the numbers
1 through <span class="math inline">\(M\)</span> (i.e.,
<code>for (m in 1:M)</code> in the loop code above). Just like in the
<code>for</code> loop above, each time we apply the generate, estimate,
and discriminate functions we created earlier. We can even simplify this
three-step process within its own “meta” function that does everything
at once.</p>
<p>The below code first defines a single function that takes as its
input the parameters you’re generating data on. The function generates
data based on it, estimates the OLS model, and pulls out the <span
class="math inline">\(\hat \tau\)</span> coefficient, all using the
functions we defined earlier.</p>
<p>Next, the code uses <code>map()</code> to replicate this process
<span class="math inline">\(M=1,000\)</span> times, and stores the
results in a vector called <code>res_sampdist</code>. We now have
reduced the loop code above to a single line of code.</p>
<div class="tutorial-exercise" data-label="basicreg1_mapex"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="14">
<pre class="text"><code>generate_estimate_discriminate &lt;- function(params) {
      params %&gt;%
        dgp_df() %&gt;%
          estimator_fn() %&gt;%
            disc_fn()
}

M = 1000
res_sampdist &lt;- 
  1:M %&gt;% 
  map_dbl(~generate_estimate_discriminate(params))

plot_sampling_distribution(res_sampdist, truth = params$tau)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
<div id="section-aside-2-updating-parameters" class="section level3">
<h3>Aside 2: Updating Parameters</h3>
<p>Now suppose we want to study some property of the estimator. For
example, in the parameter definition above we set the sample size as
1,000. What if we want to explore the sampling distribution with a
sample size of 100?</p>
<p>This is easy to do using a command called
<code>modifyList()</code></p>
<div class="tutorial-exercise" data-label="basicreg1_mapex2"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="8">
<pre class="text"><code># Let&#39;s change the sample size from 1,000 to 100 

updated_params &lt;- modifyList(params,list(N=100))
updated_params </code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
</div>
<div id="section-exercise-4-type-i-error-and-confidence-intervals"
class="section level2">
<h2>Exercise 4: Type I Error and Confidence Intervals</h2>
<p>Our next simulation exercise will pursue a different objective: to
understand whether a given approach to estimation and inference yield
the expected Type I error (i.e., failinig to reject the null when it is
not true).</p>
<p>We will do so by extracting out the 95% confidence intervals after a
regression.</p>
<p>Let’s first package up steps 1-3 (parameterize, DGP, and estimate)
into one exercise:</p>
<div class="tutorial-exercise" data-label="ci_steps1to3"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="47">
<pre class="text"><code>##################################
# Step 1: Parameterize the Problem
##################################
params =list(
  N = 1000,
  mean_x_i = 2,
  sd_x_i = 0.5,
  pr_Tx = 0.5,
  beta = 1,
  tau = 0.5,
  sigma_sq_epsilon = 1
)

####################################################
# Step 2: Define a Data Generation Process Function
#####################################################
dgp_df =function(params) {
  with(params,{
    df =
      tibble(
        x_i = rnorm(N, mean_x_i, sd_x_i),
        d_i = rbinom(N, size = 1, prob = pr_Tx),
        epsilon_i = rnorm(N, mean = 0, sd = sigma_sq_epsilon)
      ) %&gt;% 
      mutate(y_i = beta * x_i + tau * d_i + epsilon_i)
    return(df)
  })
}

############################################
# 3. Define and Apply an Estimation Function
#############################################
estimator_fn = function(df) {
  out =
    df %&gt;% 
      lm(y_i ~ x_i + d_i, data = .)
  return(out)
}

fit = 
  params %&gt;% # Step 1: Parameterize the problem
    dgp_df() %&gt;%  # Step 2: Define the data generation process
    estimator_fn() # Step 3: Apply the estimator
fit</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<p>Next, we will define a discrimination function that asks whether the
95% confidence interval contains the true value of the <span
class="math inline">\(\tau\)</span> parameter, and returns this
information as a binary variable <code>contains_truth</code>.</p>
<div class="tutorial-exercise" data-label="ci_steps4"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="17">
<pre class="text"><code>disc_fn = function(fit) {
  fit_ =broom::tidy(fit,conf.int = TRUE  )   
  out &lt;- 
    fit_ %&gt;% 
    filter(term == &quot;d_i&quot;) %&gt;%
    select(estimate, p.value, conf.low, conf.high) %&gt;% 
    # Is zero within the 95% confidence interval? 
    mutate(contains_truth = as.integer(between(params$tau,conf.low,conf.high)))

  return(out)
}

params %&gt;% # Step 1: Parameterize the problem
    dgp_df() %&gt;%  # Step 2: Define the data generation process
      estimator_fn() %&gt;%  # Step 3: Estimate 
        disc_fn() # Step 4: Pull out what you need</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<p>Next lets bundle everything up into a single function that runs it
all. TEST</p>
<div class="tutorial-exercise" data-label="ci_disc" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="10">
<pre class="text"><code>generate_estimate_discriminate &lt;- function(params) {
  params %&gt;% # Step 1: Parameterize the problem
      dgp_df() %&gt;%  # Step 2: Define the data generation process
        estimator_fn() %&gt;%  # Step 3: Estimate 
          disc_fn() # Step 4: Pull out what you need
}

params %&gt;% 
  generate_estimate_discriminate()</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<p>Our next step is to repeat this process lots of times via a Monte
Carlo simulation. We’ll keep the number of Monte Carlo runs small (1000)
to speed up computation, but note that in practice we may need to do
this thousands of times.</p>
<div class="tutorial-exercise" data-label="ci_mc" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="10">
<pre class="text"><code># Monte Carlo simulation based on 1000 different realizations of the DGP:
M = 1000
mc_result &lt;- 1:M %&gt;% map_df(~generate_estimate_discriminate(params))

# Take a peek at the output ...
mc_result %&gt;%
  head() %&gt;%
  knitr::kable()</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<p>Before we plot the results, let’s step back and think about what we
want to see. We now have a series of results from different Monte Carlo
realizations of our defined data generation process. For each simulated
dataset, we applied a linear regression estimator and extracted the 95%
confidence interval. Each time, we recorded information on whether the
interval contained the true value of the parameter, as defined in our
parameters.</p>
<p>Under standard Type I error rates, and if the underlying statistical
inference approach is working correctly, we should expect that
approximately 95% of our constructed confidence intervals will contain
the “truth.”</p>
<div class="tutorial-exercise" data-label="ci_truth" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="10">
<pre class="text"><code>mc_result %&gt;% 
  summarise(coverage = mean(contains_truth))</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<p>Finally, to provide a bit more intuition around what’s going on,
let’s plot the CIs for 100 randomly selected Monte Carlo runs from our
results:</p>
<div class="tutorial-exercise" data-label="ci_plot" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="20">
<pre class="text"><code># randomly sample 100 rows
m_ &lt;- sample(1:nrow(mc_result),100, replace = FALSE)

# plot the CIs and color them based on whether or not they contain the truth 
mc_result %&gt;% 
  filter(row_number() %in% m_) %&gt;% 
  mutate(run = row_number()) %&gt;% 
  ggplot() + 
  geom_errorbar(aes(xmin = conf.low, xmax = conf.high, y = run, colour = factor(contains_truth) )) +
  #hrbrthemes::theme_ipsum(base_size=16) +
  scale_y_discrete(breaks = NULL) +
  geom_vline(aes(xintercept = params$tau)) +
  labs(y=&quot;Monte Carlo Run&quot;, x= &quot;&quot;) + 
  theme(legend.position = &quot;none&quot;) + 
  theme(axis.title.x = element_text(size=16)) + 
  theme(axis.title.y = element_text(size=16)) </code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
<div id="section-exercise-5-omitted-variables-bias"
class="section level2">
<h2>Exercise 5: Omitted Variables Bias</h2>
<p>Our next exercise will set us up nicely for next week’s session on
panel data methods. We’re going to tweak our data generation process a
bit to include some unobserved heterogeneity (<span
class="math inline">\(u_i\)</span>) that is correlated with both
treatment and our outcome. Everything else will stay the same as
before.</p>
<div class="tutorial-exercise" data-label="omb1" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="60">
<pre class="text"><code>##################################
# Step 1: Parameterize the Problem
##################################
params =list(
  N = 1000,
  mean_x_i = 2,
  sd_x_i = 0.5,
  beta = 1,
  tau = 0.5,
  sigma_sq_epsilon = 1
)

####################################################
# Step 2: Define a Data Generation Process Function
#####################################################
dgp_df_ovb =function(params) {
  with(params,{
    df =
      tibble(
        # Covariate
        x_i = rnorm(N, mean_x_i, sd_x_i),
        # ADD UNOBSERVED HETEROGENEITY TERM
        u_i = rnorm(N, mean = 0, sd = 1)) %&gt;% 
        # Induce correlation between u_i and treatment;
        # higher values of u_i make it more likely you&#39;re treated. 
        rowwise() %&gt;% # This allows us to get each value&#39;s pr_treated in the line below. 
        mutate(pr_treated = boot::inv.logit(u_i)) %&gt;% 
        ungroup() %&gt;%  # This undoes the rowwise 
        # Treatment indicator
        mutate(d_i = rbinom(N, size = 1, prob = pr_treated)) %&gt;% 
        mutate(epsilon_i = rnorm(N, mean = 0, sd = sigma_sq_epsilon)) %&gt;% 
        # u_i is also in the DGP for y_i 
        mutate(y_i = beta * x_i + tau * d_i + u_i + epsilon_i) %&gt;% 
        # because u_i is unobserved, we strip it from the &quot;observed&quot; data output. 
        select(-u_i)
    return(df)
  })
}

############################################
# 3. Define and Apply an Estimation Function
#############################################
estimator_fn = function(df) {
  out =
    df %&gt;% 
      lm(y_i ~ x_i + d_i, data = .)
  return(out)
}

########################################
# 4. Define the discriminator function 
# (For this exercise we want to extract tau-hat 
# i.e., the coefficient on treated)
########################################
disc_fn = function(fit) {
  fit_ =broom::tidy(fit)   # This cleans up the fitted regression object
  out =fit_ %&gt;% 
    filter(term==&quot;d_i&quot;) %&gt;% 
    pull(estimate)
  
  return(out)
}

###############################################
# 5. Define a compound function that executes
# steps 1-4 based on the parameter inputs. 
###############################################

generate_estimate_discriminate &lt;- function(params) {
  params %&gt;% # Step 1: Parameterize the problem
      dgp_df_ovb() %&gt;%  # Step 2: Define the data generation process
        estimator_fn() %&gt;%  # Step 3: Estimate 
          disc_fn() %&gt;% # Step 4: Pull out what you need
            data.frame(tau_hat = .) # store the result as a data frame object
}

# Try it out
params %&gt;% generate_estimate_discriminate(.)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<p>Our next step is to repeat this process lots of times via a Monte
Carlo simulation. We’ll keep the number of Monte Carlo runs small (1000)
to speed up computation, but note that in practice we may need to do
this thousands of times.</p>
<div class="tutorial-exercise" data-label="mc_ovb" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="10">
<pre class="text"><code># Monte Carlo simulation based on 1000 different realizations of the DGP:
M = 1000
mc_result &lt;- 1:M %&gt;% map_df(~generate_estimate_discriminate(params))

# Take a peek at the output ...
mc_result %&gt;%
  head() </code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<p>Now let’s take a look at the sampling distribution of estimates.</p>
<div class="tutorial-exercise" data-label="mc_sd" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="10">
<pre class="text"><code>plot_sampling_distribution(mc_result$tau_hat, truth = params$tau)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":false,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<p>As we can see in the plot of the sampling distribution, our estimates
are biased due to the omitted factor (<span
class="math inline">\(u_i\)</span>) that is correlated with treatment
and the outcome. In our next session we will cover several estimation
approaches to obtain an unbiased estimate of <span
class="math inline">\(\tau\)</span>.</p>
<!-- Last Line -->
<p>
<script type="application/shiny-prerendered" data-context="server-start">
# load packages
library(learnr)
library(gradethis)
library(sortable)
library(tidyverse)
library(learnrhash) #devtools::install_github("rundel/learnrhash")
library(showtext)
library(googlesheets4)
library(mcreplicate)
library(knitr)
library(hrbrthemes)
#devtools::install_github("graveja0/HPOL8539PKG")
#library(HPOL8539PKG)
# devtools::load_all("../../HPOL8539PKG")


# don't echo chunks
knitr::opts_chunk$set(echo = FALSE)

# apply theme to ggplot
ggplot2::theme_set(theme_bw())

plot_sampling_distribution <- function(x,truth) {
  d <- density(x)
  p_df <- as_tibble(cbind(x = d$x, density = d$y))
  p_df %>%
    ggplot(aes(x = x, y = density)) + geom_line() +
    #hrbrthemes::theme_ipsum() +
    labs(x = "Estimate", y = "Density") +
    geom_vline(aes(xintercept = truth)) +
    annotate("text",x = mean(x), y = min(d$y*1.2), vjust=-1,label  = glue::glue("  \tMean: {formatC(mean(x),digits = 3, format='f')}\n   SD: {formatC(sd(x),digits = 3, format = 'f')}"), hjust = 0)
}

plot_cis <- function(x, K, truth) {
  res <- x %>% bind_rows(.id = "m") %>%
    as_tibble() %>%
    mutate(m = factor(m)) %>%
    mutate(m = fct_reorder(m,estimate, .desc = TRUE)) %>%
    mutate(truth = truth) %>%
    rowwise() %>%
    mutate(covered = as.integer(between(truth,conf.low,conf.high))) %>%
    ungroup() %>%
    mutate(color = ifelse(covered ==1 , "","Rejected"))
  
  K = sample(res$m,100, replace =TRUE)
  res %>%
    filter(m %in% K) %>%
    ggplot() +
    geom_errorbar(aes(xmin =  conf.low, xmax = conf.high, y= m,colour = color)) +
    #theme_ipsum() +
    scale_y_discrete(breaks = NULL) +
    geom_vline(aes(xintercept = truth)) +
    labs(title= glue("Confidence Intervals for {prettyNum(length(K),big.mark=',')} of {prettyNum(length(res$m),big.mark=',')} Estimates"),
         y= "Sampling Iteration",x = "Estimate",
         subtitle= glue("{formatC(100*mean(res$covered),digits = 1, format='f')}% of confidence intervals cover the truth")) +
    scale_colour_manual(values = c("black","red")) +
    theme(legend.position = "none")
}


</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::register_http_handlers(session, metadata = NULL)
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::prepare_tutorial_state(session)
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::i18n_observe_tutorial_language(input, session)
</script>


<script type="application/shiny-prerendered" data-context="server">
session$onSessionEnded(function() {
        learnr:::event_trigger(session, "session_stop")
      })
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-simple1-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-simple1-code-editor`)), session)
output$`tutorial-exercise-simple1-output` <- renderUI({
  `tutorial-exercise-simple1-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "simple1", global_setup = structure(c("# load packages", 
"library(learnr)", "library(gradethis)", "library(sortable)", 
"library(tidyverse)", "library(learnrhash) #devtools::install_github(\"rundel/learnrhash\")", 
"library(showtext)", "library(googlesheets4)", "library(mcreplicate)", 
"library(knitr)", "library(hrbrthemes)", "#devtools::install_github(\"graveja0/HPOL8539PKG\")", 
"#library(HPOL8539PKG)", "# devtools::load_all(\"../../HPOL8539PKG\")", 
"", "", "# don't echo chunks", "knitr::opts_chunk$set(echo = FALSE)", 
"", "# apply theme to ggplot", "ggplot2::theme_set(theme_bw())", 
"", "plot_sampling_distribution <- function(x,truth) {", "  d <- density(x)", 
"  p_df <- as_tibble(cbind(x = d$x, density = d$y))", "  p_df %>%", 
"    ggplot(aes(x = x, y = density)) + geom_line() +", "    #hrbrthemes::theme_ipsum() +", 
"    labs(x = \"Estimate\", y = \"Density\") +", "    geom_vline(aes(xintercept = truth)) +", 
"    annotate(\"text\",x = mean(x), y = min(d$y*1.2), vjust=-1,label  = glue::glue(\"  \\tMean: {formatC(mean(x),digits = 3, format='f')}\\n   SD: {formatC(sd(x),digits = 3, format = 'f')}\"), hjust = 0)", 
"}", "", "plot_cis <- function(x, K, truth) {", "  res <- x %>% bind_rows(.id = \"m\") %>%", 
"    as_tibble() %>%", "    mutate(m = factor(m)) %>%", "    mutate(m = fct_reorder(m,estimate, .desc = TRUE)) %>%", 
"    mutate(truth = truth) %>%", "    rowwise() %>%", "    mutate(covered = as.integer(between(truth,conf.low,conf.high))) %>%", 
"    ungroup() %>%", "    mutate(color = ifelse(covered ==1 , \"\",\"Rejected\"))", 
"  ", "  K = sample(res$m,100, replace =TRUE)", "  res %>%", 
"    filter(m %in% K) %>%", "    ggplot() +", "    geom_errorbar(aes(xmin =  conf.low, xmax = conf.high, y= m,colour = color)) +", 
"    #theme_ipsum() +", "    scale_y_discrete(breaks = NULL) +", 
"    geom_vline(aes(xintercept = truth)) +", "    labs(title= glue(\"Confidence Intervals for {prettyNum(length(K),big.mark=',')} of {prettyNum(length(res$m),big.mark=',')} Estimates\"),", 
"         y= \"Sampling Iteration\",x = \"Estimate\",", "         subtitle= glue(\"{formatC(100*mean(res$covered),digits = 1, format='f')}% of confidence intervals cover the truth\")) +", 
"    scale_colour_manual(values = c(\"black\",\"red\")) +", "    theme(legend.position = \"none\")", 
"}", "", ""), chunk_opts = list(label = "setup", include = FALSE)), 
    setup = NULL, chunks = list(list(label = "simple1", code = "params =\n  list(\n    N = 1000, \n    mean_x_i = 2,\n    sd_x_i = 0.5\n  )\nparams", 
        opts = list(label = "\"simple1\"", echo = "TRUE", exercise.eval = "FALSE", 
            exercise = "TRUE", exercise.lines = "8L"), engine = "r")), 
    code_check = NULL, error_check = NULL, check = NULL, solution = NULL, 
    tests = NULL, options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        label = "simple1", exercise.eval = FALSE, exercise = TRUE, 
        exercise.lines = 8L, code = c("params =", "  list(", 
        "    N = 1000, ", "    mean_x_i = 2,", "    sd_x_i = 0.5", 
        "  )", "params"), out.width.px = 624, out.height.px = 384, 
        params.src = "simple1", fig.num = 0, exercise.df_print = "paged"), 
    engine = "r", version = "3"), class = "tutorial_exercise"))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-simple1_dgp-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-simple1_dgp-code-editor`)), session)
output$`tutorial-exercise-simple1_dgp-output` <- renderUI({
  `tutorial-exercise-simple1_dgp-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "simple1_dgp", global_setup = structure(c("# load packages", 
"library(learnr)", "library(gradethis)", "library(sortable)", 
"library(tidyverse)", "library(learnrhash) #devtools::install_github(\"rundel/learnrhash\")", 
"library(showtext)", "library(googlesheets4)", "library(mcreplicate)", 
"library(knitr)", "library(hrbrthemes)", "#devtools::install_github(\"graveja0/HPOL8539PKG\")", 
"#library(HPOL8539PKG)", "# devtools::load_all(\"../../HPOL8539PKG\")", 
"", "", "# don't echo chunks", "knitr::opts_chunk$set(echo = FALSE)", 
"", "# apply theme to ggplot", "ggplot2::theme_set(theme_bw())", 
"", "plot_sampling_distribution <- function(x,truth) {", "  d <- density(x)", 
"  p_df <- as_tibble(cbind(x = d$x, density = d$y))", "  p_df %>%", 
"    ggplot(aes(x = x, y = density)) + geom_line() +", "    #hrbrthemes::theme_ipsum() +", 
"    labs(x = \"Estimate\", y = \"Density\") +", "    geom_vline(aes(xintercept = truth)) +", 
"    annotate(\"text\",x = mean(x), y = min(d$y*1.2), vjust=-1,label  = glue::glue(\"  \\tMean: {formatC(mean(x),digits = 3, format='f')}\\n   SD: {formatC(sd(x),digits = 3, format = 'f')}\"), hjust = 0)", 
"}", "", "plot_cis <- function(x, K, truth) {", "  res <- x %>% bind_rows(.id = \"m\") %>%", 
"    as_tibble() %>%", "    mutate(m = factor(m)) %>%", "    mutate(m = fct_reorder(m,estimate, .desc = TRUE)) %>%", 
"    mutate(truth = truth) %>%", "    rowwise() %>%", "    mutate(covered = as.integer(between(truth,conf.low,conf.high))) %>%", 
"    ungroup() %>%", "    mutate(color = ifelse(covered ==1 , \"\",\"Rejected\"))", 
"  ", "  K = sample(res$m,100, replace =TRUE)", "  res %>%", 
"    filter(m %in% K) %>%", "    ggplot() +", "    geom_errorbar(aes(xmin =  conf.low, xmax = conf.high, y= m,colour = color)) +", 
"    #theme_ipsum() +", "    scale_y_discrete(breaks = NULL) +", 
"    geom_vline(aes(xintercept = truth)) +", "    labs(title= glue(\"Confidence Intervals for {prettyNum(length(K),big.mark=',')} of {prettyNum(length(res$m),big.mark=',')} Estimates\"),", 
"         y= \"Sampling Iteration\",x = \"Estimate\",", "         subtitle= glue(\"{formatC(100*mean(res$covered),digits = 1, format='f')}% of confidence intervals cover the truth\")) +", 
"    scale_colour_manual(values = c(\"black\",\"red\")) +", "    theme(legend.position = \"none\")", 
"}", "", ""), chunk_opts = list(label = "setup", include = FALSE)), 
    setup = "params =\n  list(\n    N = 1000, \n    mean_x_i = 2,\n    sd_x_i = 0.5\n  )\nparams", 
    chunks = list(list(label = "simple1", code = "params =\n  list(\n    N = 1000, \n    mean_x_i = 2,\n    sd_x_i = 0.5\n  )\nparams", 
        opts = list(label = "\"simple1\"", echo = "TRUE", exercise.eval = "FALSE", 
            exercise = "TRUE", exercise.lines = "8L"), engine = "r"), 
        list(label = "simple1_dgp", code = "# Simulate a data generation process (dgp)\ndgp = function(params) {\n  with(params,{\n    x_i = rnorm(N, mean_x_i, sd_x_i)\n    return(x_i)\n  })\n}\n\nparams %>% \n  dgp()\n", 
            opts = list(label = "\"simple1_dgp\"", exercise.setup = "\"simple1\"", 
                echo = "TRUE", exercise.eval = "FALSE", exercise = "TRUE", 
                exercise.lines = "10L"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = NULL, solution = NULL, tests = NULL, 
    options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        label = "simple1_dgp", exercise.setup = "simple1", exercise.eval = FALSE, 
        exercise = TRUE, exercise.lines = 10L, code = c("# Simulate a data generation process (dgp)", 
        "dgp = function(params) {", "  with(params,{", "    x_i = rnorm(N, mean_x_i, sd_x_i)", 
        "    return(x_i)", "  })", "}", "", "params %>% ", "  dgp()", 
        ""), out.width.px = 624, out.height.px = 384, params.src = "simple1_dgp, exercise.setup = \"simple1\"", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "3"), class = "tutorial_exercise"))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-simple1_dgp3-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-simple1_dgp3-code-editor`)), session)
output$`tutorial-exercise-simple1_dgp3-output` <- renderUI({
  `tutorial-exercise-simple1_dgp3-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "simple1_dgp3", global_setup = structure(c("# load packages", 
"library(learnr)", "library(gradethis)", "library(sortable)", 
"library(tidyverse)", "library(learnrhash) #devtools::install_github(\"rundel/learnrhash\")", 
"library(showtext)", "library(googlesheets4)", "library(mcreplicate)", 
"library(knitr)", "library(hrbrthemes)", "#devtools::install_github(\"graveja0/HPOL8539PKG\")", 
"#library(HPOL8539PKG)", "# devtools::load_all(\"../../HPOL8539PKG\")", 
"", "", "# don't echo chunks", "knitr::opts_chunk$set(echo = FALSE)", 
"", "# apply theme to ggplot", "ggplot2::theme_set(theme_bw())", 
"", "plot_sampling_distribution <- function(x,truth) {", "  d <- density(x)", 
"  p_df <- as_tibble(cbind(x = d$x, density = d$y))", "  p_df %>%", 
"    ggplot(aes(x = x, y = density)) + geom_line() +", "    #hrbrthemes::theme_ipsum() +", 
"    labs(x = \"Estimate\", y = \"Density\") +", "    geom_vline(aes(xintercept = truth)) +", 
"    annotate(\"text\",x = mean(x), y = min(d$y*1.2), vjust=-1,label  = glue::glue(\"  \\tMean: {formatC(mean(x),digits = 3, format='f')}\\n   SD: {formatC(sd(x),digits = 3, format = 'f')}\"), hjust = 0)", 
"}", "", "plot_cis <- function(x, K, truth) {", "  res <- x %>% bind_rows(.id = \"m\") %>%", 
"    as_tibble() %>%", "    mutate(m = factor(m)) %>%", "    mutate(m = fct_reorder(m,estimate, .desc = TRUE)) %>%", 
"    mutate(truth = truth) %>%", "    rowwise() %>%", "    mutate(covered = as.integer(between(truth,conf.low,conf.high))) %>%", 
"    ungroup() %>%", "    mutate(color = ifelse(covered ==1 , \"\",\"Rejected\"))", 
"  ", "  K = sample(res$m,100, replace =TRUE)", "  res %>%", 
"    filter(m %in% K) %>%", "    ggplot() +", "    geom_errorbar(aes(xmin =  conf.low, xmax = conf.high, y= m,colour = color)) +", 
"    #theme_ipsum() +", "    scale_y_discrete(breaks = NULL) +", 
"    geom_vline(aes(xintercept = truth)) +", "    labs(title= glue(\"Confidence Intervals for {prettyNum(length(K),big.mark=',')} of {prettyNum(length(res$m),big.mark=',')} Estimates\"),", 
"         y= \"Sampling Iteration\",x = \"Estimate\",", "         subtitle= glue(\"{formatC(100*mean(res$covered),digits = 1, format='f')}% of confidence intervals cover the truth\")) +", 
"    scale_colour_manual(values = c(\"black\",\"red\")) +", "    theme(legend.position = \"none\")", 
"}", "", ""), chunk_opts = list(label = "setup", include = FALSE)), 
    setup = "params =\n  list(\n    N = 1000, \n    mean_x_i = 2,\n    sd_x_i = 0.5\n  )\nparams\n# Simulate a data generation process (dgp)\ndgp = function(params) {\n  with(params,{\n    x_i = rnorm(N, mean_x_i, sd_x_i)\n    return(x_i)\n  })\n}\n\nparams %>% \n  dgp()\n", 
    chunks = list(list(label = "simple1", code = "params =\n  list(\n    N = 1000, \n    mean_x_i = 2,\n    sd_x_i = 0.5\n  )\nparams", 
        opts = list(label = "\"simple1\"", echo = "TRUE", exercise.eval = "FALSE", 
            exercise = "TRUE", exercise.lines = "8L"), engine = "r"), 
        list(label = "simple1_dgp", code = "# Simulate a data generation process (dgp)\ndgp = function(params) {\n  with(params,{\n    x_i = rnorm(N, mean_x_i, sd_x_i)\n    return(x_i)\n  })\n}\n\nparams %>% \n  dgp()\n", 
            opts = list(label = "\"simple1_dgp\"", exercise.setup = "\"simple1\"", 
                echo = "TRUE", exercise.eval = "FALSE", exercise = "TRUE", 
                exercise.lines = "10L"), engine = "r"), list(
            label = "simple1_dgp3", code = "dgp_df =function(params) {\n  with(params,{\n    df =\n      tibble(\n        x_i = rnorm(N, mean_x_i, sd_x_i)\n      )\n    return(df)\n  })\n}\n\nparams %>% dgp_df()", 
            opts = list(label = "\"simple1_dgp3\"", exercise.setup = "\"simple1_dgp\"", 
                echo = "TRUE", exercise = "TRUE", `exercise-setup` = "\"simple1_dgp\"", 
                exercise.lines = "12L"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = NULL, solution = NULL, tests = NULL, 
    options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        label = "simple1_dgp3", exercise.setup = "simple1_dgp", 
        exercise = TRUE, `exercise-setup` = "simple1_dgp", exercise.lines = 12L, 
        code = c("dgp_df =function(params) {", "  with(params,{", 
        "    df =", "      tibble(", "        x_i = rnorm(N, mean_x_i, sd_x_i)", 
        "      )", "    return(df)", "  })", "}", "", "params %>% dgp_df()"
        ), out.width.px = 624, out.height.px = 384, params.src = "simple1_dgp3, exercise.setup = \"simple1_dgp\"", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "3"), class = "tutorial_exercise"))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-simple1_est1-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-simple1_est1-code-editor`)), session)
output$`tutorial-exercise-simple1_est1-output` <- renderUI({
  `tutorial-exercise-simple1_est1-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "simple1_est1", global_setup = structure(c("# load packages", 
"library(learnr)", "library(gradethis)", "library(sortable)", 
"library(tidyverse)", "library(learnrhash) #devtools::install_github(\"rundel/learnrhash\")", 
"library(showtext)", "library(googlesheets4)", "library(mcreplicate)", 
"library(knitr)", "library(hrbrthemes)", "#devtools::install_github(\"graveja0/HPOL8539PKG\")", 
"#library(HPOL8539PKG)", "# devtools::load_all(\"../../HPOL8539PKG\")", 
"", "", "# don't echo chunks", "knitr::opts_chunk$set(echo = FALSE)", 
"", "# apply theme to ggplot", "ggplot2::theme_set(theme_bw())", 
"", "plot_sampling_distribution <- function(x,truth) {", "  d <- density(x)", 
"  p_df <- as_tibble(cbind(x = d$x, density = d$y))", "  p_df %>%", 
"    ggplot(aes(x = x, y = density)) + geom_line() +", "    #hrbrthemes::theme_ipsum() +", 
"    labs(x = \"Estimate\", y = \"Density\") +", "    geom_vline(aes(xintercept = truth)) +", 
"    annotate(\"text\",x = mean(x), y = min(d$y*1.2), vjust=-1,label  = glue::glue(\"  \\tMean: {formatC(mean(x),digits = 3, format='f')}\\n   SD: {formatC(sd(x),digits = 3, format = 'f')}\"), hjust = 0)", 
"}", "", "plot_cis <- function(x, K, truth) {", "  res <- x %>% bind_rows(.id = \"m\") %>%", 
"    as_tibble() %>%", "    mutate(m = factor(m)) %>%", "    mutate(m = fct_reorder(m,estimate, .desc = TRUE)) %>%", 
"    mutate(truth = truth) %>%", "    rowwise() %>%", "    mutate(covered = as.integer(between(truth,conf.low,conf.high))) %>%", 
"    ungroup() %>%", "    mutate(color = ifelse(covered ==1 , \"\",\"Rejected\"))", 
"  ", "  K = sample(res$m,100, replace =TRUE)", "  res %>%", 
"    filter(m %in% K) %>%", "    ggplot() +", "    geom_errorbar(aes(xmin =  conf.low, xmax = conf.high, y= m,colour = color)) +", 
"    #theme_ipsum() +", "    scale_y_discrete(breaks = NULL) +", 
"    geom_vline(aes(xintercept = truth)) +", "    labs(title= glue(\"Confidence Intervals for {prettyNum(length(K),big.mark=',')} of {prettyNum(length(res$m),big.mark=',')} Estimates\"),", 
"         y= \"Sampling Iteration\",x = \"Estimate\",", "         subtitle= glue(\"{formatC(100*mean(res$covered),digits = 1, format='f')}% of confidence intervals cover the truth\")) +", 
"    scale_colour_manual(values = c(\"black\",\"red\")) +", "    theme(legend.position = \"none\")", 
"}", "", ""), chunk_opts = list(label = "setup", include = FALSE)), 
    setup = "params =\n  list(\n    N = 1000, \n    mean_x_i = 2,\n    sd_x_i = 0.5\n  )\nparams\n# Simulate a data generation process (dgp)\ndgp = function(params) {\n  with(params,{\n    x_i = rnorm(N, mean_x_i, sd_x_i)\n    return(x_i)\n  })\n}\n\nparams %>% \n  dgp()\n\ndgp_df =function(params) {\n  with(params,{\n    df =\n      tibble(\n        x_i = rnorm(N, mean_x_i, sd_x_i)\n      )\n    return(df)\n  })\n}\n\nparams %>% dgp_df()", 
    chunks = list(list(label = "simple1", code = "params =\n  list(\n    N = 1000, \n    mean_x_i = 2,\n    sd_x_i = 0.5\n  )\nparams", 
        opts = list(label = "\"simple1\"", echo = "TRUE", exercise.eval = "FALSE", 
            exercise = "TRUE", exercise.lines = "8L"), engine = "r"), 
        list(label = "simple1_dgp", code = "# Simulate a data generation process (dgp)\ndgp = function(params) {\n  with(params,{\n    x_i = rnorm(N, mean_x_i, sd_x_i)\n    return(x_i)\n  })\n}\n\nparams %>% \n  dgp()\n", 
            opts = list(label = "\"simple1_dgp\"", exercise.setup = "\"simple1\"", 
                echo = "TRUE", exercise.eval = "FALSE", exercise = "TRUE", 
                exercise.lines = "10L"), engine = "r"), list(
            label = "simple1_dgp3", code = "dgp_df =function(params) {\n  with(params,{\n    df =\n      tibble(\n        x_i = rnorm(N, mean_x_i, sd_x_i)\n      )\n    return(df)\n  })\n}\n\nparams %>% dgp_df()", 
            opts = list(label = "\"simple1_dgp3\"", exercise.setup = "\"simple1_dgp\"", 
                echo = "TRUE", exercise = "TRUE", `exercise-setup` = "\"simple1_dgp\"", 
                exercise.lines = "12L"), engine = "r"), list(
            label = "simple1_est1", code = "estimator_fn =function(df) {\n  out =\n    df %>% \n      summarise(mean_x_i = mean(x_i))\n  return(out)\n}\n\nparams %>% \n  dgp_df() %>% \n  estimator_fn()\n", 
            opts = list(label = "\"simple1_est1\"", exercise.setup = "\"simple1_dgp3\"", 
                echo = "TRUE", exercise = "TRUE", `exercise-setup` = "\"simple1_dgp\"", 
                exercise.lines = "11L"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = NULL, solution = NULL, tests = NULL, 
    options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        label = "simple1_est1", exercise.setup = "simple1_dgp3", 
        exercise = TRUE, `exercise-setup` = "simple1_dgp", exercise.lines = 11L, 
        code = c("estimator_fn =function(df) {", "  out =", "    df %>% ", 
        "      summarise(mean_x_i = mean(x_i))", "  return(out)", 
        "}", "", "params %>% ", "  dgp_df() %>% ", "  estimator_fn()", 
        ""), out.width.px = 624, out.height.px = 384, params.src = "simple1_est1, exercise.setup = \"simple1_dgp3\"", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "3"), class = "tutorial_exercise"))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-simple1_est2-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-simple1_est2-code-editor`)), session)
output$`tutorial-exercise-simple1_est2-output` <- renderUI({
  `tutorial-exercise-simple1_est2-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "simple1_est2", global_setup = structure(c("# load packages", 
"library(learnr)", "library(gradethis)", "library(sortable)", 
"library(tidyverse)", "library(learnrhash) #devtools::install_github(\"rundel/learnrhash\")", 
"library(showtext)", "library(googlesheets4)", "library(mcreplicate)", 
"library(knitr)", "library(hrbrthemes)", "#devtools::install_github(\"graveja0/HPOL8539PKG\")", 
"#library(HPOL8539PKG)", "# devtools::load_all(\"../../HPOL8539PKG\")", 
"", "", "# don't echo chunks", "knitr::opts_chunk$set(echo = FALSE)", 
"", "# apply theme to ggplot", "ggplot2::theme_set(theme_bw())", 
"", "plot_sampling_distribution <- function(x,truth) {", "  d <- density(x)", 
"  p_df <- as_tibble(cbind(x = d$x, density = d$y))", "  p_df %>%", 
"    ggplot(aes(x = x, y = density)) + geom_line() +", "    #hrbrthemes::theme_ipsum() +", 
"    labs(x = \"Estimate\", y = \"Density\") +", "    geom_vline(aes(xintercept = truth)) +", 
"    annotate(\"text\",x = mean(x), y = min(d$y*1.2), vjust=-1,label  = glue::glue(\"  \\tMean: {formatC(mean(x),digits = 3, format='f')}\\n   SD: {formatC(sd(x),digits = 3, format = 'f')}\"), hjust = 0)", 
"}", "", "plot_cis <- function(x, K, truth) {", "  res <- x %>% bind_rows(.id = \"m\") %>%", 
"    as_tibble() %>%", "    mutate(m = factor(m)) %>%", "    mutate(m = fct_reorder(m,estimate, .desc = TRUE)) %>%", 
"    mutate(truth = truth) %>%", "    rowwise() %>%", "    mutate(covered = as.integer(between(truth,conf.low,conf.high))) %>%", 
"    ungroup() %>%", "    mutate(color = ifelse(covered ==1 , \"\",\"Rejected\"))", 
"  ", "  K = sample(res$m,100, replace =TRUE)", "  res %>%", 
"    filter(m %in% K) %>%", "    ggplot() +", "    geom_errorbar(aes(xmin =  conf.low, xmax = conf.high, y= m,colour = color)) +", 
"    #theme_ipsum() +", "    scale_y_discrete(breaks = NULL) +", 
"    geom_vline(aes(xintercept = truth)) +", "    labs(title= glue(\"Confidence Intervals for {prettyNum(length(K),big.mark=',')} of {prettyNum(length(res$m),big.mark=',')} Estimates\"),", 
"         y= \"Sampling Iteration\",x = \"Estimate\",", "         subtitle= glue(\"{formatC(100*mean(res$covered),digits = 1, format='f')}% of confidence intervals cover the truth\")) +", 
"    scale_colour_manual(values = c(\"black\",\"red\")) +", "    theme(legend.position = \"none\")", 
"}", "", ""), chunk_opts = list(label = "setup", include = FALSE)), 
    setup = "params =\n  list(\n    N = 1000, \n    mean_x_i = 2,\n    sd_x_i = 0.5\n  )\nparams\n# Simulate a data generation process (dgp)\ndgp = function(params) {\n  with(params,{\n    x_i = rnorm(N, mean_x_i, sd_x_i)\n    return(x_i)\n  })\n}\n\nparams %>% \n  dgp()\n\ndgp_df =function(params) {\n  with(params,{\n    df =\n      tibble(\n        x_i = rnorm(N, mean_x_i, sd_x_i)\n      )\n    return(df)\n  })\n}\n\nparams %>% dgp_df()\nestimator_fn =function(df) {\n  out =\n    df %>% \n      summarise(mean_x_i = mean(x_i))\n  return(out)\n}\n\nparams %>% \n  dgp_df() %>% \n  estimator_fn()\n", 
    chunks = list(list(label = "simple1", code = "params =\n  list(\n    N = 1000, \n    mean_x_i = 2,\n    sd_x_i = 0.5\n  )\nparams", 
        opts = list(label = "\"simple1\"", echo = "TRUE", exercise.eval = "FALSE", 
            exercise = "TRUE", exercise.lines = "8L"), engine = "r"), 
        list(label = "simple1_dgp", code = "# Simulate a data generation process (dgp)\ndgp = function(params) {\n  with(params,{\n    x_i = rnorm(N, mean_x_i, sd_x_i)\n    return(x_i)\n  })\n}\n\nparams %>% \n  dgp()\n", 
            opts = list(label = "\"simple1_dgp\"", exercise.setup = "\"simple1\"", 
                echo = "TRUE", exercise.eval = "FALSE", exercise = "TRUE", 
                exercise.lines = "10L"), engine = "r"), list(
            label = "simple1_dgp3", code = "dgp_df =function(params) {\n  with(params,{\n    df =\n      tibble(\n        x_i = rnorm(N, mean_x_i, sd_x_i)\n      )\n    return(df)\n  })\n}\n\nparams %>% dgp_df()", 
            opts = list(label = "\"simple1_dgp3\"", exercise.setup = "\"simple1_dgp\"", 
                echo = "TRUE", exercise = "TRUE", `exercise-setup` = "\"simple1_dgp\"", 
                exercise.lines = "12L"), engine = "r"), list(
            label = "simple1_est1", code = "estimator_fn =function(df) {\n  out =\n    df %>% \n      summarise(mean_x_i = mean(x_i))\n  return(out)\n}\n\nparams %>% \n  dgp_df() %>% \n  estimator_fn()\n", 
            opts = list(label = "\"simple1_est1\"", exercise.setup = "\"simple1_dgp3\"", 
                echo = "TRUE", exercise = "TRUE", `exercise-setup` = "\"simple1_dgp\"", 
                exercise.lines = "11L"), engine = "r"), list(
            label = "simple1_est2", code = "estimator_fn_alt =function(df) {\n  out =\n    df %>% \n      summarise(mean_x_i = mean(x_i) + 1)\n  return(out)\n}\n\nparams %>% \n  dgp_df() %>% \n  estimator_fn_alt()\n\n", 
            opts = list(label = "\"simple1_est2\"", exercise.setup = "\"simple1_est1\"", 
                echo = "TRUE", exercise = "TRUE", `exercise-setup` = "\"simple1_dgp\"", 
                exercise.lines = "11L"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = NULL, solution = NULL, tests = NULL, 
    options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        label = "simple1_est2", exercise.setup = "simple1_est1", 
        exercise = TRUE, `exercise-setup` = "simple1_dgp", exercise.lines = 11L, 
        code = c("estimator_fn_alt =function(df) {", "  out =", 
        "    df %>% ", "      summarise(mean_x_i = mean(x_i) + 1)", 
        "  return(out)", "}", "", "params %>% ", "  dgp_df() %>% ", 
        "  estimator_fn_alt()", "", ""), out.width.px = 624, 
        out.height.px = 384, params.src = "simple1_est2, exercise.setup = \"simple1_est1\"", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "3"), class = "tutorial_exercise"))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-basicreg1_param-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-basicreg1_param-code-editor`)), session)
output$`tutorial-exercise-basicreg1_param-output` <- renderUI({
  `tutorial-exercise-basicreg1_param-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "basicreg1_param", global_setup = structure(c("# load packages", 
"library(learnr)", "library(gradethis)", "library(sortable)", 
"library(tidyverse)", "library(learnrhash) #devtools::install_github(\"rundel/learnrhash\")", 
"library(showtext)", "library(googlesheets4)", "library(mcreplicate)", 
"library(knitr)", "library(hrbrthemes)", "#devtools::install_github(\"graveja0/HPOL8539PKG\")", 
"#library(HPOL8539PKG)", "# devtools::load_all(\"../../HPOL8539PKG\")", 
"", "", "# don't echo chunks", "knitr::opts_chunk$set(echo = FALSE)", 
"", "# apply theme to ggplot", "ggplot2::theme_set(theme_bw())", 
"", "plot_sampling_distribution <- function(x,truth) {", "  d <- density(x)", 
"  p_df <- as_tibble(cbind(x = d$x, density = d$y))", "  p_df %>%", 
"    ggplot(aes(x = x, y = density)) + geom_line() +", "    #hrbrthemes::theme_ipsum() +", 
"    labs(x = \"Estimate\", y = \"Density\") +", "    geom_vline(aes(xintercept = truth)) +", 
"    annotate(\"text\",x = mean(x), y = min(d$y*1.2), vjust=-1,label  = glue::glue(\"  \\tMean: {formatC(mean(x),digits = 3, format='f')}\\n   SD: {formatC(sd(x),digits = 3, format = 'f')}\"), hjust = 0)", 
"}", "", "plot_cis <- function(x, K, truth) {", "  res <- x %>% bind_rows(.id = \"m\") %>%", 
"    as_tibble() %>%", "    mutate(m = factor(m)) %>%", "    mutate(m = fct_reorder(m,estimate, .desc = TRUE)) %>%", 
"    mutate(truth = truth) %>%", "    rowwise() %>%", "    mutate(covered = as.integer(between(truth,conf.low,conf.high))) %>%", 
"    ungroup() %>%", "    mutate(color = ifelse(covered ==1 , \"\",\"Rejected\"))", 
"  ", "  K = sample(res$m,100, replace =TRUE)", "  res %>%", 
"    filter(m %in% K) %>%", "    ggplot() +", "    geom_errorbar(aes(xmin =  conf.low, xmax = conf.high, y= m,colour = color)) +", 
"    #theme_ipsum() +", "    scale_y_discrete(breaks = NULL) +", 
"    geom_vline(aes(xintercept = truth)) +", "    labs(title= glue(\"Confidence Intervals for {prettyNum(length(K),big.mark=',')} of {prettyNum(length(res$m),big.mark=',')} Estimates\"),", 
"         y= \"Sampling Iteration\",x = \"Estimate\",", "         subtitle= glue(\"{formatC(100*mean(res$covered),digits = 1, format='f')}% of confidence intervals cover the truth\")) +", 
"    scale_colour_manual(values = c(\"black\",\"red\")) +", "    theme(legend.position = \"none\")", 
"}", "", ""), chunk_opts = list(label = "setup", include = FALSE)), 
    setup = NULL, chunks = list(list(label = "basicreg1_param", 
        code = "params =list(\n  N = 1000,\n  mean_x_i = 2,\n  sd_x_i = 0.5,\n  pr_Tx = 0.5,\n  beta = 1,\n  tau = 0.5,\n  sigma_sq_epsilon = 1\n)\n\nparams \n", 
        opts = list(label = "\"basicreg1_param\"", echo = "TRUE", 
            exercise = "TRUE", exercise.lines = "10L"), engine = "r")), 
    code_check = NULL, error_check = NULL, check = NULL, solution = NULL, 
    tests = NULL, options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        label = "basicreg1_param", exercise = TRUE, exercise.lines = 10L, 
        code = c("params =list(", "  N = 1000,", "  mean_x_i = 2,", 
        "  sd_x_i = 0.5,", "  pr_Tx = 0.5,", "  beta = 1,", "  tau = 0.5,", 
        "  sigma_sq_epsilon = 1", ")", "", "params ", ""), out.width.px = 624, 
        out.height.px = 384, params.src = "basicreg1_param", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "3"), class = "tutorial_exercise"))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-basicreg1_dgp-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-basicreg1_dgp-code-editor`)), session)
output$`tutorial-exercise-basicreg1_dgp-output` <- renderUI({
  `tutorial-exercise-basicreg1_dgp-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "basicreg1_dgp", global_setup = structure(c("# load packages", 
"library(learnr)", "library(gradethis)", "library(sortable)", 
"library(tidyverse)", "library(learnrhash) #devtools::install_github(\"rundel/learnrhash\")", 
"library(showtext)", "library(googlesheets4)", "library(mcreplicate)", 
"library(knitr)", "library(hrbrthemes)", "#devtools::install_github(\"graveja0/HPOL8539PKG\")", 
"#library(HPOL8539PKG)", "# devtools::load_all(\"../../HPOL8539PKG\")", 
"", "", "# don't echo chunks", "knitr::opts_chunk$set(echo = FALSE)", 
"", "# apply theme to ggplot", "ggplot2::theme_set(theme_bw())", 
"", "plot_sampling_distribution <- function(x,truth) {", "  d <- density(x)", 
"  p_df <- as_tibble(cbind(x = d$x, density = d$y))", "  p_df %>%", 
"    ggplot(aes(x = x, y = density)) + geom_line() +", "    #hrbrthemes::theme_ipsum() +", 
"    labs(x = \"Estimate\", y = \"Density\") +", "    geom_vline(aes(xintercept = truth)) +", 
"    annotate(\"text\",x = mean(x), y = min(d$y*1.2), vjust=-1,label  = glue::glue(\"  \\tMean: {formatC(mean(x),digits = 3, format='f')}\\n   SD: {formatC(sd(x),digits = 3, format = 'f')}\"), hjust = 0)", 
"}", "", "plot_cis <- function(x, K, truth) {", "  res <- x %>% bind_rows(.id = \"m\") %>%", 
"    as_tibble() %>%", "    mutate(m = factor(m)) %>%", "    mutate(m = fct_reorder(m,estimate, .desc = TRUE)) %>%", 
"    mutate(truth = truth) %>%", "    rowwise() %>%", "    mutate(covered = as.integer(between(truth,conf.low,conf.high))) %>%", 
"    ungroup() %>%", "    mutate(color = ifelse(covered ==1 , \"\",\"Rejected\"))", 
"  ", "  K = sample(res$m,100, replace =TRUE)", "  res %>%", 
"    filter(m %in% K) %>%", "    ggplot() +", "    geom_errorbar(aes(xmin =  conf.low, xmax = conf.high, y= m,colour = color)) +", 
"    #theme_ipsum() +", "    scale_y_discrete(breaks = NULL) +", 
"    geom_vline(aes(xintercept = truth)) +", "    labs(title= glue(\"Confidence Intervals for {prettyNum(length(K),big.mark=',')} of {prettyNum(length(res$m),big.mark=',')} Estimates\"),", 
"         y= \"Sampling Iteration\",x = \"Estimate\",", "         subtitle= glue(\"{formatC(100*mean(res$covered),digits = 1, format='f')}% of confidence intervals cover the truth\")) +", 
"    scale_colour_manual(values = c(\"black\",\"red\")) +", "    theme(legend.position = \"none\")", 
"}", "", ""), chunk_opts = list(label = "setup", include = FALSE)), 
    setup = "params =list(\n  N = 1000,\n  mean_x_i = 2,\n  sd_x_i = 0.5,\n  pr_Tx = 0.5,\n  beta = 1,\n  tau = 0.5,\n  sigma_sq_epsilon = 1\n)\n\nparams \n", 
    chunks = list(list(label = "basicreg1_param", code = "params =list(\n  N = 1000,\n  mean_x_i = 2,\n  sd_x_i = 0.5,\n  pr_Tx = 0.5,\n  beta = 1,\n  tau = 0.5,\n  sigma_sq_epsilon = 1\n)\n\nparams \n", 
        opts = list(label = "\"basicreg1_param\"", echo = "TRUE", 
            exercise = "TRUE", exercise.lines = "10L"), engine = "r"), 
        list(label = "basicreg1_dgp", code = "dgp_df =function(params) {\n  with(params,{\n    df =\n      tibble(\n        x_i = rnorm(N, mean_x_i, sd_x_i),\n        d_i = rbinom(N, size = 1, prob = pr_Tx),\n        epsilon_i = rnorm(N, mean = 0, sd = sigma_sq_epsilon)\n      ) %>% \n      mutate(y_i = beta * x_i + tau * d_i + epsilon_i)\n    return(df)\n  })\n}\n\nparams %>% \n  dgp_df()", 
            opts = list(label = "\"basicreg1_dgp\"", exercise.setup = "\"basicreg1_param\"", 
                echo = "TRUE", exercise = "TRUE", exercise.lines = "16L"), 
            engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        label = "basicreg1_dgp", exercise.setup = "basicreg1_param", 
        exercise = TRUE, exercise.lines = 16L, code = c("dgp_df =function(params) {", 
        "  with(params,{", "    df =", "      tibble(", "        x_i = rnorm(N, mean_x_i, sd_x_i),", 
        "        d_i = rbinom(N, size = 1, prob = pr_Tx),", "        epsilon_i = rnorm(N, mean = 0, sd = sigma_sq_epsilon)", 
        "      ) %>% ", "      mutate(y_i = beta * x_i + tau * d_i + epsilon_i)", 
        "    return(df)", "  })", "}", "", "params %>% ", "  dgp_df()"
        ), out.width.px = 624, out.height.px = 384, params.src = "basicreg1_dgp, exercise.setup = \"basicreg1_param\"", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "3"), class = "tutorial_exercise"))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-basicreg1_est-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-basicreg1_est-code-editor`)), session)
output$`tutorial-exercise-basicreg1_est-output` <- renderUI({
  `tutorial-exercise-basicreg1_est-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "basicreg1_est", global_setup = structure(c("# load packages", 
"library(learnr)", "library(gradethis)", "library(sortable)", 
"library(tidyverse)", "library(learnrhash) #devtools::install_github(\"rundel/learnrhash\")", 
"library(showtext)", "library(googlesheets4)", "library(mcreplicate)", 
"library(knitr)", "library(hrbrthemes)", "#devtools::install_github(\"graveja0/HPOL8539PKG\")", 
"#library(HPOL8539PKG)", "# devtools::load_all(\"../../HPOL8539PKG\")", 
"", "", "# don't echo chunks", "knitr::opts_chunk$set(echo = FALSE)", 
"", "# apply theme to ggplot", "ggplot2::theme_set(theme_bw())", 
"", "plot_sampling_distribution <- function(x,truth) {", "  d <- density(x)", 
"  p_df <- as_tibble(cbind(x = d$x, density = d$y))", "  p_df %>%", 
"    ggplot(aes(x = x, y = density)) + geom_line() +", "    #hrbrthemes::theme_ipsum() +", 
"    labs(x = \"Estimate\", y = \"Density\") +", "    geom_vline(aes(xintercept = truth)) +", 
"    annotate(\"text\",x = mean(x), y = min(d$y*1.2), vjust=-1,label  = glue::glue(\"  \\tMean: {formatC(mean(x),digits = 3, format='f')}\\n   SD: {formatC(sd(x),digits = 3, format = 'f')}\"), hjust = 0)", 
"}", "", "plot_cis <- function(x, K, truth) {", "  res <- x %>% bind_rows(.id = \"m\") %>%", 
"    as_tibble() %>%", "    mutate(m = factor(m)) %>%", "    mutate(m = fct_reorder(m,estimate, .desc = TRUE)) %>%", 
"    mutate(truth = truth) %>%", "    rowwise() %>%", "    mutate(covered = as.integer(between(truth,conf.low,conf.high))) %>%", 
"    ungroup() %>%", "    mutate(color = ifelse(covered ==1 , \"\",\"Rejected\"))", 
"  ", "  K = sample(res$m,100, replace =TRUE)", "  res %>%", 
"    filter(m %in% K) %>%", "    ggplot() +", "    geom_errorbar(aes(xmin =  conf.low, xmax = conf.high, y= m,colour = color)) +", 
"    #theme_ipsum() +", "    scale_y_discrete(breaks = NULL) +", 
"    geom_vline(aes(xintercept = truth)) +", "    labs(title= glue(\"Confidence Intervals for {prettyNum(length(K),big.mark=',')} of {prettyNum(length(res$m),big.mark=',')} Estimates\"),", 
"         y= \"Sampling Iteration\",x = \"Estimate\",", "         subtitle= glue(\"{formatC(100*mean(res$covered),digits = 1, format='f')}% of confidence intervals cover the truth\")) +", 
"    scale_colour_manual(values = c(\"black\",\"red\")) +", "    theme(legend.position = \"none\")", 
"}", "", ""), chunk_opts = list(label = "setup", include = FALSE)), 
    setup = "params =list(\n  N = 1000,\n  mean_x_i = 2,\n  sd_x_i = 0.5,\n  pr_Tx = 0.5,\n  beta = 1,\n  tau = 0.5,\n  sigma_sq_epsilon = 1\n)\n\nparams \n\ndgp_df =function(params) {\n  with(params,{\n    df =\n      tibble(\n        x_i = rnorm(N, mean_x_i, sd_x_i),\n        d_i = rbinom(N, size = 1, prob = pr_Tx),\n        epsilon_i = rnorm(N, mean = 0, sd = sigma_sq_epsilon)\n      ) %>% \n      mutate(y_i = beta * x_i + tau * d_i + epsilon_i)\n    return(df)\n  })\n}\n\nparams %>% \n  dgp_df()", 
    chunks = list(list(label = "basicreg1_param", code = "params =list(\n  N = 1000,\n  mean_x_i = 2,\n  sd_x_i = 0.5,\n  pr_Tx = 0.5,\n  beta = 1,\n  tau = 0.5,\n  sigma_sq_epsilon = 1\n)\n\nparams \n", 
        opts = list(label = "\"basicreg1_param\"", echo = "TRUE", 
            exercise = "TRUE", exercise.lines = "10L"), engine = "r"), 
        list(label = "basicreg1_dgp", code = "dgp_df =function(params) {\n  with(params,{\n    df =\n      tibble(\n        x_i = rnorm(N, mean_x_i, sd_x_i),\n        d_i = rbinom(N, size = 1, prob = pr_Tx),\n        epsilon_i = rnorm(N, mean = 0, sd = sigma_sq_epsilon)\n      ) %>% \n      mutate(y_i = beta * x_i + tau * d_i + epsilon_i)\n    return(df)\n  })\n}\n\nparams %>% \n  dgp_df()", 
            opts = list(label = "\"basicreg1_dgp\"", exercise.setup = "\"basicreg1_param\"", 
                echo = "TRUE", exercise = "TRUE", exercise.lines = "16L"), 
            engine = "r"), list(label = "basicreg1_est", code = "estimator_fn = function(df) {\n  out =\n    df %>% \n      lm(y_i ~ x_i + d_i, data = .)\n  return(out)\n}\n\nfit1 = \n  params %>% # Step 1: Parameterize the problem\n    dgp_df() %>%  # Step 2: Define the data generation process\n    estimator_fn() # Step 3: Apply the estimator\nfit1 ", 
            opts = list(label = "\"basicreg1_est\"", exercise.setup = "\"basicreg1_dgp\"", 
                echo = "TRUE", exercise = "TRUE", exercise.lines = "15L"), 
            engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        label = "basicreg1_est", exercise.setup = "basicreg1_dgp", 
        exercise = TRUE, exercise.lines = 15L, code = c("estimator_fn = function(df) {", 
        "  out =", "    df %>% ", "      lm(y_i ~ x_i + d_i, data = .)", 
        "  return(out)", "}", "", "fit1 = ", "  params %>% # Step 1: Parameterize the problem", 
        "    dgp_df() %>%  # Step 2: Define the data generation process", 
        "    estimator_fn() # Step 3: Apply the estimator", "fit1 "
        ), out.width.px = 624, out.height.px = 384, params.src = "basicreg1_est, exercise.setup = \"basicreg1_dgp\"", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "3"), class = "tutorial_exercise"))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-basicreg1_disc1-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-basicreg1_disc1-code-editor`)), session)
output$`tutorial-exercise-basicreg1_disc1-output` <- renderUI({
  `tutorial-exercise-basicreg1_disc1-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "basicreg1_disc1", global_setup = structure(c("# load packages", 
"library(learnr)", "library(gradethis)", "library(sortable)", 
"library(tidyverse)", "library(learnrhash) #devtools::install_github(\"rundel/learnrhash\")", 
"library(showtext)", "library(googlesheets4)", "library(mcreplicate)", 
"library(knitr)", "library(hrbrthemes)", "#devtools::install_github(\"graveja0/HPOL8539PKG\")", 
"#library(HPOL8539PKG)", "# devtools::load_all(\"../../HPOL8539PKG\")", 
"", "", "# don't echo chunks", "knitr::opts_chunk$set(echo = FALSE)", 
"", "# apply theme to ggplot", "ggplot2::theme_set(theme_bw())", 
"", "plot_sampling_distribution <- function(x,truth) {", "  d <- density(x)", 
"  p_df <- as_tibble(cbind(x = d$x, density = d$y))", "  p_df %>%", 
"    ggplot(aes(x = x, y = density)) + geom_line() +", "    #hrbrthemes::theme_ipsum() +", 
"    labs(x = \"Estimate\", y = \"Density\") +", "    geom_vline(aes(xintercept = truth)) +", 
"    annotate(\"text\",x = mean(x), y = min(d$y*1.2), vjust=-1,label  = glue::glue(\"  \\tMean: {formatC(mean(x),digits = 3, format='f')}\\n   SD: {formatC(sd(x),digits = 3, format = 'f')}\"), hjust = 0)", 
"}", "", "plot_cis <- function(x, K, truth) {", "  res <- x %>% bind_rows(.id = \"m\") %>%", 
"    as_tibble() %>%", "    mutate(m = factor(m)) %>%", "    mutate(m = fct_reorder(m,estimate, .desc = TRUE)) %>%", 
"    mutate(truth = truth) %>%", "    rowwise() %>%", "    mutate(covered = as.integer(between(truth,conf.low,conf.high))) %>%", 
"    ungroup() %>%", "    mutate(color = ifelse(covered ==1 , \"\",\"Rejected\"))", 
"  ", "  K = sample(res$m,100, replace =TRUE)", "  res %>%", 
"    filter(m %in% K) %>%", "    ggplot() +", "    geom_errorbar(aes(xmin =  conf.low, xmax = conf.high, y= m,colour = color)) +", 
"    #theme_ipsum() +", "    scale_y_discrete(breaks = NULL) +", 
"    geom_vline(aes(xintercept = truth)) +", "    labs(title= glue(\"Confidence Intervals for {prettyNum(length(K),big.mark=',')} of {prettyNum(length(res$m),big.mark=',')} Estimates\"),", 
"         y= \"Sampling Iteration\",x = \"Estimate\",", "         subtitle= glue(\"{formatC(100*mean(res$covered),digits = 1, format='f')}% of confidence intervals cover the truth\")) +", 
"    scale_colour_manual(values = c(\"black\",\"red\")) +", "    theme(legend.position = \"none\")", 
"}", "", ""), chunk_opts = list(label = "setup", include = FALSE)), 
    setup = "params =list(\n  N = 1000,\n  mean_x_i = 2,\n  sd_x_i = 0.5,\n  pr_Tx = 0.5,\n  beta = 1,\n  tau = 0.5,\n  sigma_sq_epsilon = 1\n)\n\nparams \n\ndgp_df =function(params) {\n  with(params,{\n    df =\n      tibble(\n        x_i = rnorm(N, mean_x_i, sd_x_i),\n        d_i = rbinom(N, size = 1, prob = pr_Tx),\n        epsilon_i = rnorm(N, mean = 0, sd = sigma_sq_epsilon)\n      ) %>% \n      mutate(y_i = beta * x_i + tau * d_i + epsilon_i)\n    return(df)\n  })\n}\n\nparams %>% \n  dgp_df()\nestimator_fn = function(df) {\n  out =\n    df %>% \n      lm(y_i ~ x_i + d_i, data = .)\n  return(out)\n}\n\nfit1 = \n  params %>% # Step 1: Parameterize the problem\n    dgp_df() %>%  # Step 2: Define the data generation process\n    estimator_fn() # Step 3: Apply the estimator\nfit1 ", 
    chunks = list(list(label = "basicreg1_param", code = "params =list(\n  N = 1000,\n  mean_x_i = 2,\n  sd_x_i = 0.5,\n  pr_Tx = 0.5,\n  beta = 1,\n  tau = 0.5,\n  sigma_sq_epsilon = 1\n)\n\nparams \n", 
        opts = list(label = "\"basicreg1_param\"", echo = "TRUE", 
            exercise = "TRUE", exercise.lines = "10L"), engine = "r"), 
        list(label = "basicreg1_dgp", code = "dgp_df =function(params) {\n  with(params,{\n    df =\n      tibble(\n        x_i = rnorm(N, mean_x_i, sd_x_i),\n        d_i = rbinom(N, size = 1, prob = pr_Tx),\n        epsilon_i = rnorm(N, mean = 0, sd = sigma_sq_epsilon)\n      ) %>% \n      mutate(y_i = beta * x_i + tau * d_i + epsilon_i)\n    return(df)\n  })\n}\n\nparams %>% \n  dgp_df()", 
            opts = list(label = "\"basicreg1_dgp\"", exercise.setup = "\"basicreg1_param\"", 
                echo = "TRUE", exercise = "TRUE", exercise.lines = "16L"), 
            engine = "r"), list(label = "basicreg1_est", code = "estimator_fn = function(df) {\n  out =\n    df %>% \n      lm(y_i ~ x_i + d_i, data = .)\n  return(out)\n}\n\nfit1 = \n  params %>% # Step 1: Parameterize the problem\n    dgp_df() %>%  # Step 2: Define the data generation process\n    estimator_fn() # Step 3: Apply the estimator\nfit1 ", 
            opts = list(label = "\"basicreg1_est\"", exercise.setup = "\"basicreg1_dgp\"", 
                echo = "TRUE", exercise = "TRUE", exercise.lines = "15L"), 
            engine = "r"), list(label = "basicreg1_disc1", code = "disc_fn = function(fit) {\n  fit_ =broom::tidy(fit)   # This cleans up the fitted regression object\n  out =fit_ %>% \n    filter(term==\"d_i\") %>% \n    pull(estimate)\n  \n  return(out)\n}\n\n# First, take a look at what tidy() does. \nbroom::tidy(fit1)\n\n# Next, apply the discriminator function to the estimated regression\ndisc_fn(fit1)\n\n", 
            opts = list(label = "\"basicreg1_disc1\"", exercise.setup = "\"basicreg1_est\"", 
                echo = "TRUE", exercise = "TRUE", exercise.lines = "15L"), 
            engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        label = "basicreg1_disc1", exercise.setup = "basicreg1_est", 
        exercise = TRUE, exercise.lines = 15L, code = c("disc_fn = function(fit) {", 
        "  fit_ =broom::tidy(fit)   # This cleans up the fitted regression object", 
        "  out =fit_ %>% ", "    filter(term==\"d_i\") %>% ", 
        "    pull(estimate)", "  ", "  return(out)", "}", "", 
        "# First, take a look at what tidy() does. ", "broom::tidy(fit1)", 
        "", "# Next, apply the discriminator function to the estimated regression", 
        "disc_fn(fit1)", "", ""), out.width.px = 624, out.height.px = 384, 
        params.src = "basicreg1_disc1, exercise.setup = \"basicreg1_est\"", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "3"), class = "tutorial_exercise"))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-basicreg1_disc2-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-basicreg1_disc2-code-editor`)), session)
output$`tutorial-exercise-basicreg1_disc2-output` <- renderUI({
  `tutorial-exercise-basicreg1_disc2-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "basicreg1_disc2", global_setup = structure(c("# load packages", 
"library(learnr)", "library(gradethis)", "library(sortable)", 
"library(tidyverse)", "library(learnrhash) #devtools::install_github(\"rundel/learnrhash\")", 
"library(showtext)", "library(googlesheets4)", "library(mcreplicate)", 
"library(knitr)", "library(hrbrthemes)", "#devtools::install_github(\"graveja0/HPOL8539PKG\")", 
"#library(HPOL8539PKG)", "# devtools::load_all(\"../../HPOL8539PKG\")", 
"", "", "# don't echo chunks", "knitr::opts_chunk$set(echo = FALSE)", 
"", "# apply theme to ggplot", "ggplot2::theme_set(theme_bw())", 
"", "plot_sampling_distribution <- function(x,truth) {", "  d <- density(x)", 
"  p_df <- as_tibble(cbind(x = d$x, density = d$y))", "  p_df %>%", 
"    ggplot(aes(x = x, y = density)) + geom_line() +", "    #hrbrthemes::theme_ipsum() +", 
"    labs(x = \"Estimate\", y = \"Density\") +", "    geom_vline(aes(xintercept = truth)) +", 
"    annotate(\"text\",x = mean(x), y = min(d$y*1.2), vjust=-1,label  = glue::glue(\"  \\tMean: {formatC(mean(x),digits = 3, format='f')}\\n   SD: {formatC(sd(x),digits = 3, format = 'f')}\"), hjust = 0)", 
"}", "", "plot_cis <- function(x, K, truth) {", "  res <- x %>% bind_rows(.id = \"m\") %>%", 
"    as_tibble() %>%", "    mutate(m = factor(m)) %>%", "    mutate(m = fct_reorder(m,estimate, .desc = TRUE)) %>%", 
"    mutate(truth = truth) %>%", "    rowwise() %>%", "    mutate(covered = as.integer(between(truth,conf.low,conf.high))) %>%", 
"    ungroup() %>%", "    mutate(color = ifelse(covered ==1 , \"\",\"Rejected\"))", 
"  ", "  K = sample(res$m,100, replace =TRUE)", "  res %>%", 
"    filter(m %in% K) %>%", "    ggplot() +", "    geom_errorbar(aes(xmin =  conf.low, xmax = conf.high, y= m,colour = color)) +", 
"    #theme_ipsum() +", "    scale_y_discrete(breaks = NULL) +", 
"    geom_vline(aes(xintercept = truth)) +", "    labs(title= glue(\"Confidence Intervals for {prettyNum(length(K),big.mark=',')} of {prettyNum(length(res$m),big.mark=',')} Estimates\"),", 
"         y= \"Sampling Iteration\",x = \"Estimate\",", "         subtitle= glue(\"{formatC(100*mean(res$covered),digits = 1, format='f')}% of confidence intervals cover the truth\")) +", 
"    scale_colour_manual(values = c(\"black\",\"red\")) +", "    theme(legend.position = \"none\")", 
"}", "", ""), chunk_opts = list(label = "setup", include = FALSE)), 
    setup = "params =list(\n  N = 1000,\n  mean_x_i = 2,\n  sd_x_i = 0.5,\n  pr_Tx = 0.5,\n  beta = 1,\n  tau = 0.5,\n  sigma_sq_epsilon = 1\n)\n\nparams \n\ndgp_df =function(params) {\n  with(params,{\n    df =\n      tibble(\n        x_i = rnorm(N, mean_x_i, sd_x_i),\n        d_i = rbinom(N, size = 1, prob = pr_Tx),\n        epsilon_i = rnorm(N, mean = 0, sd = sigma_sq_epsilon)\n      ) %>% \n      mutate(y_i = beta * x_i + tau * d_i + epsilon_i)\n    return(df)\n  })\n}\n\nparams %>% \n  dgp_df()\nestimator_fn = function(df) {\n  out =\n    df %>% \n      lm(y_i ~ x_i + d_i, data = .)\n  return(out)\n}\n\nfit1 = \n  params %>% # Step 1: Parameterize the problem\n    dgp_df() %>%  # Step 2: Define the data generation process\n    estimator_fn() # Step 3: Apply the estimator\nfit1 \ndisc_fn = function(fit) {\n  fit_ =broom::tidy(fit)   # This cleans up the fitted regression object\n  out =fit_ %>% \n    filter(term==\"d_i\") %>% \n    pull(estimate)\n  \n  return(out)\n}\n\n# First, take a look at what tidy() does. \nbroom::tidy(fit1)\n\n# Next, apply the discriminator function to the estimated regression\ndisc_fn(fit1)\n\n", 
    chunks = list(list(label = "basicreg1_param", code = "params =list(\n  N = 1000,\n  mean_x_i = 2,\n  sd_x_i = 0.5,\n  pr_Tx = 0.5,\n  beta = 1,\n  tau = 0.5,\n  sigma_sq_epsilon = 1\n)\n\nparams \n", 
        opts = list(label = "\"basicreg1_param\"", echo = "TRUE", 
            exercise = "TRUE", exercise.lines = "10L"), engine = "r"), 
        list(label = "basicreg1_dgp", code = "dgp_df =function(params) {\n  with(params,{\n    df =\n      tibble(\n        x_i = rnorm(N, mean_x_i, sd_x_i),\n        d_i = rbinom(N, size = 1, prob = pr_Tx),\n        epsilon_i = rnorm(N, mean = 0, sd = sigma_sq_epsilon)\n      ) %>% \n      mutate(y_i = beta * x_i + tau * d_i + epsilon_i)\n    return(df)\n  })\n}\n\nparams %>% \n  dgp_df()", 
            opts = list(label = "\"basicreg1_dgp\"", exercise.setup = "\"basicreg1_param\"", 
                echo = "TRUE", exercise = "TRUE", exercise.lines = "16L"), 
            engine = "r"), list(label = "basicreg1_est", code = "estimator_fn = function(df) {\n  out =\n    df %>% \n      lm(y_i ~ x_i + d_i, data = .)\n  return(out)\n}\n\nfit1 = \n  params %>% # Step 1: Parameterize the problem\n    dgp_df() %>%  # Step 2: Define the data generation process\n    estimator_fn() # Step 3: Apply the estimator\nfit1 ", 
            opts = list(label = "\"basicreg1_est\"", exercise.setup = "\"basicreg1_dgp\"", 
                echo = "TRUE", exercise = "TRUE", exercise.lines = "15L"), 
            engine = "r"), list(label = "basicreg1_disc1", code = "disc_fn = function(fit) {\n  fit_ =broom::tidy(fit)   # This cleans up the fitted regression object\n  out =fit_ %>% \n    filter(term==\"d_i\") %>% \n    pull(estimate)\n  \n  return(out)\n}\n\n# First, take a look at what tidy() does. \nbroom::tidy(fit1)\n\n# Next, apply the discriminator function to the estimated regression\ndisc_fn(fit1)\n\n", 
            opts = list(label = "\"basicreg1_disc1\"", exercise.setup = "\"basicreg1_est\"", 
                echo = "TRUE", exercise = "TRUE", exercise.lines = "15L"), 
            engine = "r"), list(label = "basicreg1_disc2", code = "# Run it once...\nparams %>% \n  dgp_df() %>% \n    estimator_fn() %>% \n      disc_fn()\n      \n# Run it again...\nparams %>% \n  dgp_df() %>% \n    estimator_fn() %>% \n      disc_fn()\n      \n# Run it a third time!    \nparams %>% \n  dgp_df() %>% \n    estimator_fn() %>% \n      disc_fn()", 
            opts = list(label = "\"basicreg1_disc2\"", exercise.setup = "\"basicreg1_disc1\"", 
                echo = "TRUE", exercise = "TRUE", exercise.lines = "18L"), 
            engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        label = "basicreg1_disc2", exercise.setup = "basicreg1_disc1", 
        exercise = TRUE, exercise.lines = 18L, code = c("# Run it once...", 
        "params %>% ", "  dgp_df() %>% ", "    estimator_fn() %>% ", 
        "      disc_fn()", "      ", "# Run it again...", "params %>% ", 
        "  dgp_df() %>% ", "    estimator_fn() %>% ", "      disc_fn()", 
        "      ", "# Run it a third time!    ", "params %>% ", 
        "  dgp_df() %>% ", "    estimator_fn() %>% ", "      disc_fn()"
        ), out.width.px = 624, out.height.px = 384, params.src = "basicreg1_disc2, exercise.setup = \"basicreg1_disc1\"", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "3"), class = "tutorial_exercise"))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-basicreg1_mcgen-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-basicreg1_mcgen-code-editor`)), session)
output$`tutorial-exercise-basicreg1_mcgen-output` <- renderUI({
  `tutorial-exercise-basicreg1_mcgen-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "basicreg1_mcgen", global_setup = structure(c("# load packages", 
"library(learnr)", "library(gradethis)", "library(sortable)", 
"library(tidyverse)", "library(learnrhash) #devtools::install_github(\"rundel/learnrhash\")", 
"library(showtext)", "library(googlesheets4)", "library(mcreplicate)", 
"library(knitr)", "library(hrbrthemes)", "#devtools::install_github(\"graveja0/HPOL8539PKG\")", 
"#library(HPOL8539PKG)", "# devtools::load_all(\"../../HPOL8539PKG\")", 
"", "", "# don't echo chunks", "knitr::opts_chunk$set(echo = FALSE)", 
"", "# apply theme to ggplot", "ggplot2::theme_set(theme_bw())", 
"", "plot_sampling_distribution <- function(x,truth) {", "  d <- density(x)", 
"  p_df <- as_tibble(cbind(x = d$x, density = d$y))", "  p_df %>%", 
"    ggplot(aes(x = x, y = density)) + geom_line() +", "    #hrbrthemes::theme_ipsum() +", 
"    labs(x = \"Estimate\", y = \"Density\") +", "    geom_vline(aes(xintercept = truth)) +", 
"    annotate(\"text\",x = mean(x), y = min(d$y*1.2), vjust=-1,label  = glue::glue(\"  \\tMean: {formatC(mean(x),digits = 3, format='f')}\\n   SD: {formatC(sd(x),digits = 3, format = 'f')}\"), hjust = 0)", 
"}", "", "plot_cis <- function(x, K, truth) {", "  res <- x %>% bind_rows(.id = \"m\") %>%", 
"    as_tibble() %>%", "    mutate(m = factor(m)) %>%", "    mutate(m = fct_reorder(m,estimate, .desc = TRUE)) %>%", 
"    mutate(truth = truth) %>%", "    rowwise() %>%", "    mutate(covered = as.integer(between(truth,conf.low,conf.high))) %>%", 
"    ungroup() %>%", "    mutate(color = ifelse(covered ==1 , \"\",\"Rejected\"))", 
"  ", "  K = sample(res$m,100, replace =TRUE)", "  res %>%", 
"    filter(m %in% K) %>%", "    ggplot() +", "    geom_errorbar(aes(xmin =  conf.low, xmax = conf.high, y= m,colour = color)) +", 
"    #theme_ipsum() +", "    scale_y_discrete(breaks = NULL) +", 
"    geom_vline(aes(xintercept = truth)) +", "    labs(title= glue(\"Confidence Intervals for {prettyNum(length(K),big.mark=',')} of {prettyNum(length(res$m),big.mark=',')} Estimates\"),", 
"         y= \"Sampling Iteration\",x = \"Estimate\",", "         subtitle= glue(\"{formatC(100*mean(res$covered),digits = 1, format='f')}% of confidence intervals cover the truth\")) +", 
"    scale_colour_manual(values = c(\"black\",\"red\")) +", "    theme(legend.position = \"none\")", 
"}", "", ""), chunk_opts = list(label = "setup", include = FALSE)), 
    setup = "params =list(\n  N = 1000,\n  mean_x_i = 2,\n  sd_x_i = 0.5,\n  pr_Tx = 0.5,\n  beta = 1,\n  tau = 0.5,\n  sigma_sq_epsilon = 1\n)\n\nparams \n\ndgp_df =function(params) {\n  with(params,{\n    df =\n      tibble(\n        x_i = rnorm(N, mean_x_i, sd_x_i),\n        d_i = rbinom(N, size = 1, prob = pr_Tx),\n        epsilon_i = rnorm(N, mean = 0, sd = sigma_sq_epsilon)\n      ) %>% \n      mutate(y_i = beta * x_i + tau * d_i + epsilon_i)\n    return(df)\n  })\n}\n\nparams %>% \n  dgp_df()\nestimator_fn = function(df) {\n  out =\n    df %>% \n      lm(y_i ~ x_i + d_i, data = .)\n  return(out)\n}\n\nfit1 = \n  params %>% # Step 1: Parameterize the problem\n    dgp_df() %>%  # Step 2: Define the data generation process\n    estimator_fn() # Step 3: Apply the estimator\nfit1 \ndisc_fn = function(fit) {\n  fit_ =broom::tidy(fit)   # This cleans up the fitted regression object\n  out =fit_ %>% \n    filter(term==\"d_i\") %>% \n    pull(estimate)\n  \n  return(out)\n}\n\n# First, take a look at what tidy() does. \nbroom::tidy(fit1)\n\n# Next, apply the discriminator function to the estimated regression\ndisc_fn(fit1)\n\n", 
    chunks = list(list(label = "basicreg1_param", code = "params =list(\n  N = 1000,\n  mean_x_i = 2,\n  sd_x_i = 0.5,\n  pr_Tx = 0.5,\n  beta = 1,\n  tau = 0.5,\n  sigma_sq_epsilon = 1\n)\n\nparams \n", 
        opts = list(label = "\"basicreg1_param\"", echo = "TRUE", 
            exercise = "TRUE", exercise.lines = "10L"), engine = "r"), 
        list(label = "basicreg1_dgp", code = "dgp_df =function(params) {\n  with(params,{\n    df =\n      tibble(\n        x_i = rnorm(N, mean_x_i, sd_x_i),\n        d_i = rbinom(N, size = 1, prob = pr_Tx),\n        epsilon_i = rnorm(N, mean = 0, sd = sigma_sq_epsilon)\n      ) %>% \n      mutate(y_i = beta * x_i + tau * d_i + epsilon_i)\n    return(df)\n  })\n}\n\nparams %>% \n  dgp_df()", 
            opts = list(label = "\"basicreg1_dgp\"", exercise.setup = "\"basicreg1_param\"", 
                echo = "TRUE", exercise = "TRUE", exercise.lines = "16L"), 
            engine = "r"), list(label = "basicreg1_est", code = "estimator_fn = function(df) {\n  out =\n    df %>% \n      lm(y_i ~ x_i + d_i, data = .)\n  return(out)\n}\n\nfit1 = \n  params %>% # Step 1: Parameterize the problem\n    dgp_df() %>%  # Step 2: Define the data generation process\n    estimator_fn() # Step 3: Apply the estimator\nfit1 ", 
            opts = list(label = "\"basicreg1_est\"", exercise.setup = "\"basicreg1_dgp\"", 
                echo = "TRUE", exercise = "TRUE", exercise.lines = "15L"), 
            engine = "r"), list(label = "basicreg1_disc1", code = "disc_fn = function(fit) {\n  fit_ =broom::tidy(fit)   # This cleans up the fitted regression object\n  out =fit_ %>% \n    filter(term==\"d_i\") %>% \n    pull(estimate)\n  \n  return(out)\n}\n\n# First, take a look at what tidy() does. \nbroom::tidy(fit1)\n\n# Next, apply the discriminator function to the estimated regression\ndisc_fn(fit1)\n\n", 
            opts = list(label = "\"basicreg1_disc1\"", exercise.setup = "\"basicreg1_est\"", 
                echo = "TRUE", exercise = "TRUE", exercise.lines = "15L"), 
            engine = "r"), list(label = "basicreg1_mcgen", code = "M = 1000\n\nres_sampdist <- c() # we start with a basic (empty) object. \n\n# Loop over the generation, estimation, discrimination process\n# M times, each time storing the result\nfor (m in 1:M) {\n  # We're just going to append the result on the end of the result opbject\n  res_sampdist <- \n    c(res_sampdist, \n      # You've seen all this before ... \n      params %>%\n        dgp_df() %>%\n          estimator_fn() %>%\n            disc_fn()\n  )\n}\nplot_sampling_distribution(res_sampdist,truth=params$tau)\n", 
            opts = list(label = "\"basicreg1_mcgen\"", exercise.setup = "\"basicreg1_disc1\"", 
                echo = "TRUE", exercise = "TRUE", exercise.lines = "20L"), 
            engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        label = "basicreg1_mcgen", exercise.setup = "basicreg1_disc1", 
        exercise = TRUE, exercise.lines = 20L, code = c("M = 1000", 
        "", "res_sampdist <- c() # we start with a basic (empty) object. ", 
        "", "# Loop over the generation, estimation, discrimination process", 
        "# M times, each time storing the result", "for (m in 1:M) {", 
        "  # We're just going to append the result on the end of the result opbject", 
        "  res_sampdist <- ", "    c(res_sampdist, ", "      # You've seen all this before ... ", 
        "      params %>%", "        dgp_df() %>%", "          estimator_fn() %>%", 
        "            disc_fn()", "  )", "}", "plot_sampling_distribution(res_sampdist,truth=params$tau)", 
        ""), out.width.px = 624, out.height.px = 384, params.src = "basicreg1_mcgen, exercise.setup = \"basicreg1_disc1\"", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "3"), class = "tutorial_exercise"))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-basicreg1_mapex-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-basicreg1_mapex-code-editor`)), session)
output$`tutorial-exercise-basicreg1_mapex-output` <- renderUI({
  `tutorial-exercise-basicreg1_mapex-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "basicreg1_mapex", global_setup = structure(c("# load packages", 
"library(learnr)", "library(gradethis)", "library(sortable)", 
"library(tidyverse)", "library(learnrhash) #devtools::install_github(\"rundel/learnrhash\")", 
"library(showtext)", "library(googlesheets4)", "library(mcreplicate)", 
"library(knitr)", "library(hrbrthemes)", "#devtools::install_github(\"graveja0/HPOL8539PKG\")", 
"#library(HPOL8539PKG)", "# devtools::load_all(\"../../HPOL8539PKG\")", 
"", "", "# don't echo chunks", "knitr::opts_chunk$set(echo = FALSE)", 
"", "# apply theme to ggplot", "ggplot2::theme_set(theme_bw())", 
"", "plot_sampling_distribution <- function(x,truth) {", "  d <- density(x)", 
"  p_df <- as_tibble(cbind(x = d$x, density = d$y))", "  p_df %>%", 
"    ggplot(aes(x = x, y = density)) + geom_line() +", "    #hrbrthemes::theme_ipsum() +", 
"    labs(x = \"Estimate\", y = \"Density\") +", "    geom_vline(aes(xintercept = truth)) +", 
"    annotate(\"text\",x = mean(x), y = min(d$y*1.2), vjust=-1,label  = glue::glue(\"  \\tMean: {formatC(mean(x),digits = 3, format='f')}\\n   SD: {formatC(sd(x),digits = 3, format = 'f')}\"), hjust = 0)", 
"}", "", "plot_cis <- function(x, K, truth) {", "  res <- x %>% bind_rows(.id = \"m\") %>%", 
"    as_tibble() %>%", "    mutate(m = factor(m)) %>%", "    mutate(m = fct_reorder(m,estimate, .desc = TRUE)) %>%", 
"    mutate(truth = truth) %>%", "    rowwise() %>%", "    mutate(covered = as.integer(between(truth,conf.low,conf.high))) %>%", 
"    ungroup() %>%", "    mutate(color = ifelse(covered ==1 , \"\",\"Rejected\"))", 
"  ", "  K = sample(res$m,100, replace =TRUE)", "  res %>%", 
"    filter(m %in% K) %>%", "    ggplot() +", "    geom_errorbar(aes(xmin =  conf.low, xmax = conf.high, y= m,colour = color)) +", 
"    #theme_ipsum() +", "    scale_y_discrete(breaks = NULL) +", 
"    geom_vline(aes(xintercept = truth)) +", "    labs(title= glue(\"Confidence Intervals for {prettyNum(length(K),big.mark=',')} of {prettyNum(length(res$m),big.mark=',')} Estimates\"),", 
"         y= \"Sampling Iteration\",x = \"Estimate\",", "         subtitle= glue(\"{formatC(100*mean(res$covered),digits = 1, format='f')}% of confidence intervals cover the truth\")) +", 
"    scale_colour_manual(values = c(\"black\",\"red\")) +", "    theme(legend.position = \"none\")", 
"}", "", ""), chunk_opts = list(label = "setup", include = FALSE)), 
    setup = "params =list(\n  N = 1000,\n  mean_x_i = 2,\n  sd_x_i = 0.5,\n  pr_Tx = 0.5,\n  beta = 1,\n  tau = 0.5,\n  sigma_sq_epsilon = 1\n)\n\nparams \n\ndgp_df =function(params) {\n  with(params,{\n    df =\n      tibble(\n        x_i = rnorm(N, mean_x_i, sd_x_i),\n        d_i = rbinom(N, size = 1, prob = pr_Tx),\n        epsilon_i = rnorm(N, mean = 0, sd = sigma_sq_epsilon)\n      ) %>% \n      mutate(y_i = beta * x_i + tau * d_i + epsilon_i)\n    return(df)\n  })\n}\n\nparams %>% \n  dgp_df()\nestimator_fn = function(df) {\n  out =\n    df %>% \n      lm(y_i ~ x_i + d_i, data = .)\n  return(out)\n}\n\nfit1 = \n  params %>% # Step 1: Parameterize the problem\n    dgp_df() %>%  # Step 2: Define the data generation process\n    estimator_fn() # Step 3: Apply the estimator\nfit1 \ndisc_fn = function(fit) {\n  fit_ =broom::tidy(fit)   # This cleans up the fitted regression object\n  out =fit_ %>% \n    filter(term==\"d_i\") %>% \n    pull(estimate)\n  \n  return(out)\n}\n\n# First, take a look at what tidy() does. \nbroom::tidy(fit1)\n\n# Next, apply the discriminator function to the estimated regression\ndisc_fn(fit1)\n\n", 
    chunks = list(list(label = "basicreg1_param", code = "params =list(\n  N = 1000,\n  mean_x_i = 2,\n  sd_x_i = 0.5,\n  pr_Tx = 0.5,\n  beta = 1,\n  tau = 0.5,\n  sigma_sq_epsilon = 1\n)\n\nparams \n", 
        opts = list(label = "\"basicreg1_param\"", echo = "TRUE", 
            exercise = "TRUE", exercise.lines = "10L"), engine = "r"), 
        list(label = "basicreg1_dgp", code = "dgp_df =function(params) {\n  with(params,{\n    df =\n      tibble(\n        x_i = rnorm(N, mean_x_i, sd_x_i),\n        d_i = rbinom(N, size = 1, prob = pr_Tx),\n        epsilon_i = rnorm(N, mean = 0, sd = sigma_sq_epsilon)\n      ) %>% \n      mutate(y_i = beta * x_i + tau * d_i + epsilon_i)\n    return(df)\n  })\n}\n\nparams %>% \n  dgp_df()", 
            opts = list(label = "\"basicreg1_dgp\"", exercise.setup = "\"basicreg1_param\"", 
                echo = "TRUE", exercise = "TRUE", exercise.lines = "16L"), 
            engine = "r"), list(label = "basicreg1_est", code = "estimator_fn = function(df) {\n  out =\n    df %>% \n      lm(y_i ~ x_i + d_i, data = .)\n  return(out)\n}\n\nfit1 = \n  params %>% # Step 1: Parameterize the problem\n    dgp_df() %>%  # Step 2: Define the data generation process\n    estimator_fn() # Step 3: Apply the estimator\nfit1 ", 
            opts = list(label = "\"basicreg1_est\"", exercise.setup = "\"basicreg1_dgp\"", 
                echo = "TRUE", exercise = "TRUE", exercise.lines = "15L"), 
            engine = "r"), list(label = "basicreg1_disc1", code = "disc_fn = function(fit) {\n  fit_ =broom::tidy(fit)   # This cleans up the fitted regression object\n  out =fit_ %>% \n    filter(term==\"d_i\") %>% \n    pull(estimate)\n  \n  return(out)\n}\n\n# First, take a look at what tidy() does. \nbroom::tidy(fit1)\n\n# Next, apply the discriminator function to the estimated regression\ndisc_fn(fit1)\n\n", 
            opts = list(label = "\"basicreg1_disc1\"", exercise.setup = "\"basicreg1_est\"", 
                echo = "TRUE", exercise = "TRUE", exercise.lines = "15L"), 
            engine = "r"), list(label = "basicreg1_mapex", code = "generate_estimate_discriminate <- function(params) {\n      params %>%\n        dgp_df() %>%\n          estimator_fn() %>%\n            disc_fn()\n}\n\nM = 1000\nres_sampdist <- \n  1:M %>% \n  map_dbl(~generate_estimate_discriminate(params))\n\nplot_sampling_distribution(res_sampdist, truth = params$tau)\n", 
            opts = list(label = "\"basicreg1_mapex\"", exercise.setup = "\"basicreg1_disc1\"", 
                echo = "TRUE", exercise = "TRUE", exercise.lines = "14L"), 
            engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        label = "basicreg1_mapex", exercise.setup = "basicreg1_disc1", 
        exercise = TRUE, exercise.lines = 14L, code = c("generate_estimate_discriminate <- function(params) {", 
        "      params %>%", "        dgp_df() %>%", "          estimator_fn() %>%", 
        "            disc_fn()", "}", "", "M = 1000", "res_sampdist <- ", 
        "  1:M %>% ", "  map_dbl(~generate_estimate_discriminate(params))", 
        "", "plot_sampling_distribution(res_sampdist, truth = params$tau)", 
        ""), out.width.px = 624, out.height.px = 384, params.src = "basicreg1_mapex, exercise.setup = \"basicreg1_disc1\"", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "3"), class = "tutorial_exercise"))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-basicreg1_mapex2-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-basicreg1_mapex2-code-editor`)), session)
output$`tutorial-exercise-basicreg1_mapex2-output` <- renderUI({
  `tutorial-exercise-basicreg1_mapex2-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "basicreg1_mapex2", global_setup = structure(c("# load packages", 
"library(learnr)", "library(gradethis)", "library(sortable)", 
"library(tidyverse)", "library(learnrhash) #devtools::install_github(\"rundel/learnrhash\")", 
"library(showtext)", "library(googlesheets4)", "library(mcreplicate)", 
"library(knitr)", "library(hrbrthemes)", "#devtools::install_github(\"graveja0/HPOL8539PKG\")", 
"#library(HPOL8539PKG)", "# devtools::load_all(\"../../HPOL8539PKG\")", 
"", "", "# don't echo chunks", "knitr::opts_chunk$set(echo = FALSE)", 
"", "# apply theme to ggplot", "ggplot2::theme_set(theme_bw())", 
"", "plot_sampling_distribution <- function(x,truth) {", "  d <- density(x)", 
"  p_df <- as_tibble(cbind(x = d$x, density = d$y))", "  p_df %>%", 
"    ggplot(aes(x = x, y = density)) + geom_line() +", "    #hrbrthemes::theme_ipsum() +", 
"    labs(x = \"Estimate\", y = \"Density\") +", "    geom_vline(aes(xintercept = truth)) +", 
"    annotate(\"text\",x = mean(x), y = min(d$y*1.2), vjust=-1,label  = glue::glue(\"  \\tMean: {formatC(mean(x),digits = 3, format='f')}\\n   SD: {formatC(sd(x),digits = 3, format = 'f')}\"), hjust = 0)", 
"}", "", "plot_cis <- function(x, K, truth) {", "  res <- x %>% bind_rows(.id = \"m\") %>%", 
"    as_tibble() %>%", "    mutate(m = factor(m)) %>%", "    mutate(m = fct_reorder(m,estimate, .desc = TRUE)) %>%", 
"    mutate(truth = truth) %>%", "    rowwise() %>%", "    mutate(covered = as.integer(between(truth,conf.low,conf.high))) %>%", 
"    ungroup() %>%", "    mutate(color = ifelse(covered ==1 , \"\",\"Rejected\"))", 
"  ", "  K = sample(res$m,100, replace =TRUE)", "  res %>%", 
"    filter(m %in% K) %>%", "    ggplot() +", "    geom_errorbar(aes(xmin =  conf.low, xmax = conf.high, y= m,colour = color)) +", 
"    #theme_ipsum() +", "    scale_y_discrete(breaks = NULL) +", 
"    geom_vline(aes(xintercept = truth)) +", "    labs(title= glue(\"Confidence Intervals for {prettyNum(length(K),big.mark=',')} of {prettyNum(length(res$m),big.mark=',')} Estimates\"),", 
"         y= \"Sampling Iteration\",x = \"Estimate\",", "         subtitle= glue(\"{formatC(100*mean(res$covered),digits = 1, format='f')}% of confidence intervals cover the truth\")) +", 
"    scale_colour_manual(values = c(\"black\",\"red\")) +", "    theme(legend.position = \"none\")", 
"}", "", ""), chunk_opts = list(label = "setup", include = FALSE)), 
    setup = "params =list(\n  N = 1000,\n  mean_x_i = 2,\n  sd_x_i = 0.5,\n  pr_Tx = 0.5,\n  beta = 1,\n  tau = 0.5,\n  sigma_sq_epsilon = 1\n)\n\nparams \n\ndgp_df =function(params) {\n  with(params,{\n    df =\n      tibble(\n        x_i = rnorm(N, mean_x_i, sd_x_i),\n        d_i = rbinom(N, size = 1, prob = pr_Tx),\n        epsilon_i = rnorm(N, mean = 0, sd = sigma_sq_epsilon)\n      ) %>% \n      mutate(y_i = beta * x_i + tau * d_i + epsilon_i)\n    return(df)\n  })\n}\n\nparams %>% \n  dgp_df()\nestimator_fn = function(df) {\n  out =\n    df %>% \n      lm(y_i ~ x_i + d_i, data = .)\n  return(out)\n}\n\nfit1 = \n  params %>% # Step 1: Parameterize the problem\n    dgp_df() %>%  # Step 2: Define the data generation process\n    estimator_fn() # Step 3: Apply the estimator\nfit1 \ndisc_fn = function(fit) {\n  fit_ =broom::tidy(fit)   # This cleans up the fitted regression object\n  out =fit_ %>% \n    filter(term==\"d_i\") %>% \n    pull(estimate)\n  \n  return(out)\n}\n\n# First, take a look at what tidy() does. \nbroom::tidy(fit1)\n\n# Next, apply the discriminator function to the estimated regression\ndisc_fn(fit1)\n\n\ngenerate_estimate_discriminate <- function(params) {\n      params %>%\n        dgp_df() %>%\n          estimator_fn() %>%\n            disc_fn()\n}\n\nM = 1000\nres_sampdist <- \n  1:M %>% \n  map_dbl(~generate_estimate_discriminate(params))\n\nplot_sampling_distribution(res_sampdist, truth = params$tau)\n", 
    chunks = list(list(label = "basicreg1_param", code = "params =list(\n  N = 1000,\n  mean_x_i = 2,\n  sd_x_i = 0.5,\n  pr_Tx = 0.5,\n  beta = 1,\n  tau = 0.5,\n  sigma_sq_epsilon = 1\n)\n\nparams \n", 
        opts = list(label = "\"basicreg1_param\"", echo = "TRUE", 
            exercise = "TRUE", exercise.lines = "10L"), engine = "r"), 
        list(label = "basicreg1_dgp", code = "dgp_df =function(params) {\n  with(params,{\n    df =\n      tibble(\n        x_i = rnorm(N, mean_x_i, sd_x_i),\n        d_i = rbinom(N, size = 1, prob = pr_Tx),\n        epsilon_i = rnorm(N, mean = 0, sd = sigma_sq_epsilon)\n      ) %>% \n      mutate(y_i = beta * x_i + tau * d_i + epsilon_i)\n    return(df)\n  })\n}\n\nparams %>% \n  dgp_df()", 
            opts = list(label = "\"basicreg1_dgp\"", exercise.setup = "\"basicreg1_param\"", 
                echo = "TRUE", exercise = "TRUE", exercise.lines = "16L"), 
            engine = "r"), list(label = "basicreg1_est", code = "estimator_fn = function(df) {\n  out =\n    df %>% \n      lm(y_i ~ x_i + d_i, data = .)\n  return(out)\n}\n\nfit1 = \n  params %>% # Step 1: Parameterize the problem\n    dgp_df() %>%  # Step 2: Define the data generation process\n    estimator_fn() # Step 3: Apply the estimator\nfit1 ", 
            opts = list(label = "\"basicreg1_est\"", exercise.setup = "\"basicreg1_dgp\"", 
                echo = "TRUE", exercise = "TRUE", exercise.lines = "15L"), 
            engine = "r"), list(label = "basicreg1_disc1", code = "disc_fn = function(fit) {\n  fit_ =broom::tidy(fit)   # This cleans up the fitted regression object\n  out =fit_ %>% \n    filter(term==\"d_i\") %>% \n    pull(estimate)\n  \n  return(out)\n}\n\n# First, take a look at what tidy() does. \nbroom::tidy(fit1)\n\n# Next, apply the discriminator function to the estimated regression\ndisc_fn(fit1)\n\n", 
            opts = list(label = "\"basicreg1_disc1\"", exercise.setup = "\"basicreg1_est\"", 
                echo = "TRUE", exercise = "TRUE", exercise.lines = "15L"), 
            engine = "r"), list(label = "basicreg1_mapex", code = "generate_estimate_discriminate <- function(params) {\n      params %>%\n        dgp_df() %>%\n          estimator_fn() %>%\n            disc_fn()\n}\n\nM = 1000\nres_sampdist <- \n  1:M %>% \n  map_dbl(~generate_estimate_discriminate(params))\n\nplot_sampling_distribution(res_sampdist, truth = params$tau)\n", 
            opts = list(label = "\"basicreg1_mapex\"", exercise.setup = "\"basicreg1_disc1\"", 
                echo = "TRUE", exercise = "TRUE", exercise.lines = "14L"), 
            engine = "r"), list(label = "basicreg1_mapex2", code = "# Let's change the sample size from 1,000 to 100 \n\nupdated_params <- modifyList(params,list(N=100))\nupdated_params \n", 
            opts = list(label = "\"basicreg1_mapex2\"", exercise.setup = "\"basicreg1_mapex\"", 
                echo = "TRUE", exercise = "TRUE", exercise.lines = "8L"), 
            engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        label = "basicreg1_mapex2", exercise.setup = "basicreg1_mapex", 
        exercise = TRUE, exercise.lines = 8L, code = c("# Let's change the sample size from 1,000 to 100 ", 
        "", "updated_params <- modifyList(params,list(N=100))", 
        "updated_params ", ""), out.width.px = 624, out.height.px = 384, 
        params.src = "basicreg1_mapex2, exercise.setup = \"basicreg1_mapex\"", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "3"), class = "tutorial_exercise"))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-ci_steps1to3-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-ci_steps1to3-code-editor`)), session)
output$`tutorial-exercise-ci_steps1to3-output` <- renderUI({
  `tutorial-exercise-ci_steps1to3-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "ci_steps1to3", global_setup = structure(c("# load packages", 
"library(learnr)", "library(gradethis)", "library(sortable)", 
"library(tidyverse)", "library(learnrhash) #devtools::install_github(\"rundel/learnrhash\")", 
"library(showtext)", "library(googlesheets4)", "library(mcreplicate)", 
"library(knitr)", "library(hrbrthemes)", "#devtools::install_github(\"graveja0/HPOL8539PKG\")", 
"#library(HPOL8539PKG)", "# devtools::load_all(\"../../HPOL8539PKG\")", 
"", "", "# don't echo chunks", "knitr::opts_chunk$set(echo = FALSE)", 
"", "# apply theme to ggplot", "ggplot2::theme_set(theme_bw())", 
"", "plot_sampling_distribution <- function(x,truth) {", "  d <- density(x)", 
"  p_df <- as_tibble(cbind(x = d$x, density = d$y))", "  p_df %>%", 
"    ggplot(aes(x = x, y = density)) + geom_line() +", "    #hrbrthemes::theme_ipsum() +", 
"    labs(x = \"Estimate\", y = \"Density\") +", "    geom_vline(aes(xintercept = truth)) +", 
"    annotate(\"text\",x = mean(x), y = min(d$y*1.2), vjust=-1,label  = glue::glue(\"  \\tMean: {formatC(mean(x),digits = 3, format='f')}\\n   SD: {formatC(sd(x),digits = 3, format = 'f')}\"), hjust = 0)", 
"}", "", "plot_cis <- function(x, K, truth) {", "  res <- x %>% bind_rows(.id = \"m\") %>%", 
"    as_tibble() %>%", "    mutate(m = factor(m)) %>%", "    mutate(m = fct_reorder(m,estimate, .desc = TRUE)) %>%", 
"    mutate(truth = truth) %>%", "    rowwise() %>%", "    mutate(covered = as.integer(between(truth,conf.low,conf.high))) %>%", 
"    ungroup() %>%", "    mutate(color = ifelse(covered ==1 , \"\",\"Rejected\"))", 
"  ", "  K = sample(res$m,100, replace =TRUE)", "  res %>%", 
"    filter(m %in% K) %>%", "    ggplot() +", "    geom_errorbar(aes(xmin =  conf.low, xmax = conf.high, y= m,colour = color)) +", 
"    #theme_ipsum() +", "    scale_y_discrete(breaks = NULL) +", 
"    geom_vline(aes(xintercept = truth)) +", "    labs(title= glue(\"Confidence Intervals for {prettyNum(length(K),big.mark=',')} of {prettyNum(length(res$m),big.mark=',')} Estimates\"),", 
"         y= \"Sampling Iteration\",x = \"Estimate\",", "         subtitle= glue(\"{formatC(100*mean(res$covered),digits = 1, format='f')}% of confidence intervals cover the truth\")) +", 
"    scale_colour_manual(values = c(\"black\",\"red\")) +", "    theme(legend.position = \"none\")", 
"}", "", ""), chunk_opts = list(label = "setup", include = FALSE)), 
    setup = NULL, chunks = list(list(label = "ci_steps1to3", 
        code = "##################################\n# Step 1: Parameterize the Problem\n##################################\nparams =list(\n  N = 1000,\n  mean_x_i = 2,\n  sd_x_i = 0.5,\n  pr_Tx = 0.5,\n  beta = 1,\n  tau = 0.5,\n  sigma_sq_epsilon = 1\n)\n\n####################################################\n# Step 2: Define a Data Generation Process Function\n#####################################################\ndgp_df =function(params) {\n  with(params,{\n    df =\n      tibble(\n        x_i = rnorm(N, mean_x_i, sd_x_i),\n        d_i = rbinom(N, size = 1, prob = pr_Tx),\n        epsilon_i = rnorm(N, mean = 0, sd = sigma_sq_epsilon)\n      ) %>% \n      mutate(y_i = beta * x_i + tau * d_i + epsilon_i)\n    return(df)\n  })\n}\n\n############################################\n# 3. Define and Apply an Estimation Function\n#############################################\nestimator_fn = function(df) {\n  out =\n    df %>% \n      lm(y_i ~ x_i + d_i, data = .)\n  return(out)\n}\n\nfit = \n  params %>% # Step 1: Parameterize the problem\n    dgp_df() %>%  # Step 2: Define the data generation process\n    estimator_fn() # Step 3: Apply the estimator\nfit\n\n", 
        opts = list(label = "\"ci_steps1to3\"", echo = "TRUE", 
            exercise = "TRUE", exercise.lines = "47L"), engine = "r")), 
    code_check = NULL, error_check = NULL, check = NULL, solution = NULL, 
    tests = NULL, options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        label = "ci_steps1to3", exercise = TRUE, exercise.lines = 47L, 
        code = c("##################################", "# Step 1: Parameterize the Problem", 
        "##################################", "params =list(", 
        "  N = 1000,", "  mean_x_i = 2,", "  sd_x_i = 0.5,", 
        "  pr_Tx = 0.5,", "  beta = 1,", "  tau = 0.5,", "  sigma_sq_epsilon = 1", 
        ")", "", "####################################################", 
        "# Step 2: Define a Data Generation Process Function", 
        "#####################################################", 
        "dgp_df =function(params) {", "  with(params,{", "    df =", 
        "      tibble(", "        x_i = rnorm(N, mean_x_i, sd_x_i),", 
        "        d_i = rbinom(N, size = 1, prob = pr_Tx),", "        epsilon_i = rnorm(N, mean = 0, sd = sigma_sq_epsilon)", 
        "      ) %>% ", "      mutate(y_i = beta * x_i + tau * d_i + epsilon_i)", 
        "    return(df)", "  })", "}", "", "############################################", 
        "# 3. Define and Apply an Estimation Function", "#############################################", 
        "estimator_fn = function(df) {", "  out =", "    df %>% ", 
        "      lm(y_i ~ x_i + d_i, data = .)", "  return(out)", 
        "}", "", "fit = ", "  params %>% # Step 1: Parameterize the problem", 
        "    dgp_df() %>%  # Step 2: Define the data generation process", 
        "    estimator_fn() # Step 3: Apply the estimator", "fit", 
        "", ""), out.width.px = 624, out.height.px = 384, params.src = "ci_steps1to3", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "3"), class = "tutorial_exercise"))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-ci_steps4-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-ci_steps4-code-editor`)), session)
output$`tutorial-exercise-ci_steps4-output` <- renderUI({
  `tutorial-exercise-ci_steps4-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "ci_steps4", global_setup = structure(c("# load packages", 
"library(learnr)", "library(gradethis)", "library(sortable)", 
"library(tidyverse)", "library(learnrhash) #devtools::install_github(\"rundel/learnrhash\")", 
"library(showtext)", "library(googlesheets4)", "library(mcreplicate)", 
"library(knitr)", "library(hrbrthemes)", "#devtools::install_github(\"graveja0/HPOL8539PKG\")", 
"#library(HPOL8539PKG)", "# devtools::load_all(\"../../HPOL8539PKG\")", 
"", "", "# don't echo chunks", "knitr::opts_chunk$set(echo = FALSE)", 
"", "# apply theme to ggplot", "ggplot2::theme_set(theme_bw())", 
"", "plot_sampling_distribution <- function(x,truth) {", "  d <- density(x)", 
"  p_df <- as_tibble(cbind(x = d$x, density = d$y))", "  p_df %>%", 
"    ggplot(aes(x = x, y = density)) + geom_line() +", "    #hrbrthemes::theme_ipsum() +", 
"    labs(x = \"Estimate\", y = \"Density\") +", "    geom_vline(aes(xintercept = truth)) +", 
"    annotate(\"text\",x = mean(x), y = min(d$y*1.2), vjust=-1,label  = glue::glue(\"  \\tMean: {formatC(mean(x),digits = 3, format='f')}\\n   SD: {formatC(sd(x),digits = 3, format = 'f')}\"), hjust = 0)", 
"}", "", "plot_cis <- function(x, K, truth) {", "  res <- x %>% bind_rows(.id = \"m\") %>%", 
"    as_tibble() %>%", "    mutate(m = factor(m)) %>%", "    mutate(m = fct_reorder(m,estimate, .desc = TRUE)) %>%", 
"    mutate(truth = truth) %>%", "    rowwise() %>%", "    mutate(covered = as.integer(between(truth,conf.low,conf.high))) %>%", 
"    ungroup() %>%", "    mutate(color = ifelse(covered ==1 , \"\",\"Rejected\"))", 
"  ", "  K = sample(res$m,100, replace =TRUE)", "  res %>%", 
"    filter(m %in% K) %>%", "    ggplot() +", "    geom_errorbar(aes(xmin =  conf.low, xmax = conf.high, y= m,colour = color)) +", 
"    #theme_ipsum() +", "    scale_y_discrete(breaks = NULL) +", 
"    geom_vline(aes(xintercept = truth)) +", "    labs(title= glue(\"Confidence Intervals for {prettyNum(length(K),big.mark=',')} of {prettyNum(length(res$m),big.mark=',')} Estimates\"),", 
"         y= \"Sampling Iteration\",x = \"Estimate\",", "         subtitle= glue(\"{formatC(100*mean(res$covered),digits = 1, format='f')}% of confidence intervals cover the truth\")) +", 
"    scale_colour_manual(values = c(\"black\",\"red\")) +", "    theme(legend.position = \"none\")", 
"}", "", ""), chunk_opts = list(label = "setup", include = FALSE)), 
    setup = "##################################\n# Step 1: Parameterize the Problem\n##################################\nparams =list(\n  N = 1000,\n  mean_x_i = 2,\n  sd_x_i = 0.5,\n  pr_Tx = 0.5,\n  beta = 1,\n  tau = 0.5,\n  sigma_sq_epsilon = 1\n)\n\n####################################################\n# Step 2: Define a Data Generation Process Function\n#####################################################\ndgp_df =function(params) {\n  with(params,{\n    df =\n      tibble(\n        x_i = rnorm(N, mean_x_i, sd_x_i),\n        d_i = rbinom(N, size = 1, prob = pr_Tx),\n        epsilon_i = rnorm(N, mean = 0, sd = sigma_sq_epsilon)\n      ) %>% \n      mutate(y_i = beta * x_i + tau * d_i + epsilon_i)\n    return(df)\n  })\n}\n\n############################################\n# 3. Define and Apply an Estimation Function\n#############################################\nestimator_fn = function(df) {\n  out =\n    df %>% \n      lm(y_i ~ x_i + d_i, data = .)\n  return(out)\n}\n\nfit = \n  params %>% # Step 1: Parameterize the problem\n    dgp_df() %>%  # Step 2: Define the data generation process\n    estimator_fn() # Step 3: Apply the estimator\nfit\n\n", 
    chunks = list(list(label = "ci_steps1to3", code = "##################################\n# Step 1: Parameterize the Problem\n##################################\nparams =list(\n  N = 1000,\n  mean_x_i = 2,\n  sd_x_i = 0.5,\n  pr_Tx = 0.5,\n  beta = 1,\n  tau = 0.5,\n  sigma_sq_epsilon = 1\n)\n\n####################################################\n# Step 2: Define a Data Generation Process Function\n#####################################################\ndgp_df =function(params) {\n  with(params,{\n    df =\n      tibble(\n        x_i = rnorm(N, mean_x_i, sd_x_i),\n        d_i = rbinom(N, size = 1, prob = pr_Tx),\n        epsilon_i = rnorm(N, mean = 0, sd = sigma_sq_epsilon)\n      ) %>% \n      mutate(y_i = beta * x_i + tau * d_i + epsilon_i)\n    return(df)\n  })\n}\n\n############################################\n# 3. Define and Apply an Estimation Function\n#############################################\nestimator_fn = function(df) {\n  out =\n    df %>% \n      lm(y_i ~ x_i + d_i, data = .)\n  return(out)\n}\n\nfit = \n  params %>% # Step 1: Parameterize the problem\n    dgp_df() %>%  # Step 2: Define the data generation process\n    estimator_fn() # Step 3: Apply the estimator\nfit\n\n", 
        opts = list(label = "\"ci_steps1to3\"", echo = "TRUE", 
            exercise = "TRUE", exercise.lines = "47L"), engine = "r"), 
        list(label = "ci_steps4", code = "disc_fn = function(fit) {\n  fit_ =broom::tidy(fit,conf.int = TRUE  )   \n  out <- \n    fit_ %>% \n    filter(term == \"d_i\") %>%\n    select(estimate, p.value, conf.low, conf.high) %>% \n    # Is zero within the 95% confidence interval? \n    mutate(contains_truth = as.integer(between(params$tau,conf.low,conf.high)))\n\n  return(out)\n}\n\nparams %>% # Step 1: Parameterize the problem\n    dgp_df() %>%  # Step 2: Define the data generation process\n      estimator_fn() %>%  # Step 3: Estimate \n        disc_fn() # Step 4: Pull out what you need", 
            opts = list(label = "\"ci_steps4\"", exercise.setup = "\"ci_steps1to3\"", 
                echo = "TRUE", exercise = "TRUE", exercise.lines = "17L"), 
            engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        label = "ci_steps4", exercise.setup = "ci_steps1to3", 
        exercise = TRUE, exercise.lines = 17L, code = c("disc_fn = function(fit) {", 
        "  fit_ =broom::tidy(fit,conf.int = TRUE  )   ", "  out <- ", 
        "    fit_ %>% ", "    filter(term == \"d_i\") %>%", "    select(estimate, p.value, conf.low, conf.high) %>% ", 
        "    # Is zero within the 95% confidence interval? ", 
        "    mutate(contains_truth = as.integer(between(params$tau,conf.low,conf.high)))", 
        "", "  return(out)", "}", "", "params %>% # Step 1: Parameterize the problem", 
        "    dgp_df() %>%  # Step 2: Define the data generation process", 
        "      estimator_fn() %>%  # Step 3: Estimate ", "        disc_fn() # Step 4: Pull out what you need"
        ), out.width.px = 624, out.height.px = 384, params.src = "ci_steps4, exercise.setup = \"ci_steps1to3\"", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "3"), class = "tutorial_exercise"))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-ci_disc-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-ci_disc-code-editor`)), session)
output$`tutorial-exercise-ci_disc-output` <- renderUI({
  `tutorial-exercise-ci_disc-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "ci_disc", global_setup = structure(c("# load packages", 
"library(learnr)", "library(gradethis)", "library(sortable)", 
"library(tidyverse)", "library(learnrhash) #devtools::install_github(\"rundel/learnrhash\")", 
"library(showtext)", "library(googlesheets4)", "library(mcreplicate)", 
"library(knitr)", "library(hrbrthemes)", "#devtools::install_github(\"graveja0/HPOL8539PKG\")", 
"#library(HPOL8539PKG)", "# devtools::load_all(\"../../HPOL8539PKG\")", 
"", "", "# don't echo chunks", "knitr::opts_chunk$set(echo = FALSE)", 
"", "# apply theme to ggplot", "ggplot2::theme_set(theme_bw())", 
"", "plot_sampling_distribution <- function(x,truth) {", "  d <- density(x)", 
"  p_df <- as_tibble(cbind(x = d$x, density = d$y))", "  p_df %>%", 
"    ggplot(aes(x = x, y = density)) + geom_line() +", "    #hrbrthemes::theme_ipsum() +", 
"    labs(x = \"Estimate\", y = \"Density\") +", "    geom_vline(aes(xintercept = truth)) +", 
"    annotate(\"text\",x = mean(x), y = min(d$y*1.2), vjust=-1,label  = glue::glue(\"  \\tMean: {formatC(mean(x),digits = 3, format='f')}\\n   SD: {formatC(sd(x),digits = 3, format = 'f')}\"), hjust = 0)", 
"}", "", "plot_cis <- function(x, K, truth) {", "  res <- x %>% bind_rows(.id = \"m\") %>%", 
"    as_tibble() %>%", "    mutate(m = factor(m)) %>%", "    mutate(m = fct_reorder(m,estimate, .desc = TRUE)) %>%", 
"    mutate(truth = truth) %>%", "    rowwise() %>%", "    mutate(covered = as.integer(between(truth,conf.low,conf.high))) %>%", 
"    ungroup() %>%", "    mutate(color = ifelse(covered ==1 , \"\",\"Rejected\"))", 
"  ", "  K = sample(res$m,100, replace =TRUE)", "  res %>%", 
"    filter(m %in% K) %>%", "    ggplot() +", "    geom_errorbar(aes(xmin =  conf.low, xmax = conf.high, y= m,colour = color)) +", 
"    #theme_ipsum() +", "    scale_y_discrete(breaks = NULL) +", 
"    geom_vline(aes(xintercept = truth)) +", "    labs(title= glue(\"Confidence Intervals for {prettyNum(length(K),big.mark=',')} of {prettyNum(length(res$m),big.mark=',')} Estimates\"),", 
"         y= \"Sampling Iteration\",x = \"Estimate\",", "         subtitle= glue(\"{formatC(100*mean(res$covered),digits = 1, format='f')}% of confidence intervals cover the truth\")) +", 
"    scale_colour_manual(values = c(\"black\",\"red\")) +", "    theme(legend.position = \"none\")", 
"}", "", ""), chunk_opts = list(label = "setup", include = FALSE)), 
    setup = "##################################\n# Step 1: Parameterize the Problem\n##################################\nparams =list(\n  N = 1000,\n  mean_x_i = 2,\n  sd_x_i = 0.5,\n  pr_Tx = 0.5,\n  beta = 1,\n  tau = 0.5,\n  sigma_sq_epsilon = 1\n)\n\n####################################################\n# Step 2: Define a Data Generation Process Function\n#####################################################\ndgp_df =function(params) {\n  with(params,{\n    df =\n      tibble(\n        x_i = rnorm(N, mean_x_i, sd_x_i),\n        d_i = rbinom(N, size = 1, prob = pr_Tx),\n        epsilon_i = rnorm(N, mean = 0, sd = sigma_sq_epsilon)\n      ) %>% \n      mutate(y_i = beta * x_i + tau * d_i + epsilon_i)\n    return(df)\n  })\n}\n\n############################################\n# 3. Define and Apply an Estimation Function\n#############################################\nestimator_fn = function(df) {\n  out =\n    df %>% \n      lm(y_i ~ x_i + d_i, data = .)\n  return(out)\n}\n\nfit = \n  params %>% # Step 1: Parameterize the problem\n    dgp_df() %>%  # Step 2: Define the data generation process\n    estimator_fn() # Step 3: Apply the estimator\nfit\n\n\ndisc_fn = function(fit) {\n  fit_ =broom::tidy(fit,conf.int = TRUE  )   \n  out <- \n    fit_ %>% \n    filter(term == \"d_i\") %>%\n    select(estimate, p.value, conf.low, conf.high) %>% \n    # Is zero within the 95% confidence interval? \n    mutate(contains_truth = as.integer(between(params$tau,conf.low,conf.high)))\n\n  return(out)\n}\n\nparams %>% # Step 1: Parameterize the problem\n    dgp_df() %>%  # Step 2: Define the data generation process\n      estimator_fn() %>%  # Step 3: Estimate \n        disc_fn() # Step 4: Pull out what you need", 
    chunks = list(list(label = "ci_steps1to3", code = "##################################\n# Step 1: Parameterize the Problem\n##################################\nparams =list(\n  N = 1000,\n  mean_x_i = 2,\n  sd_x_i = 0.5,\n  pr_Tx = 0.5,\n  beta = 1,\n  tau = 0.5,\n  sigma_sq_epsilon = 1\n)\n\n####################################################\n# Step 2: Define a Data Generation Process Function\n#####################################################\ndgp_df =function(params) {\n  with(params,{\n    df =\n      tibble(\n        x_i = rnorm(N, mean_x_i, sd_x_i),\n        d_i = rbinom(N, size = 1, prob = pr_Tx),\n        epsilon_i = rnorm(N, mean = 0, sd = sigma_sq_epsilon)\n      ) %>% \n      mutate(y_i = beta * x_i + tau * d_i + epsilon_i)\n    return(df)\n  })\n}\n\n############################################\n# 3. Define and Apply an Estimation Function\n#############################################\nestimator_fn = function(df) {\n  out =\n    df %>% \n      lm(y_i ~ x_i + d_i, data = .)\n  return(out)\n}\n\nfit = \n  params %>% # Step 1: Parameterize the problem\n    dgp_df() %>%  # Step 2: Define the data generation process\n    estimator_fn() # Step 3: Apply the estimator\nfit\n\n", 
        opts = list(label = "\"ci_steps1to3\"", echo = "TRUE", 
            exercise = "TRUE", exercise.lines = "47L"), engine = "r"), 
        list(label = "ci_steps4", code = "disc_fn = function(fit) {\n  fit_ =broom::tidy(fit,conf.int = TRUE  )   \n  out <- \n    fit_ %>% \n    filter(term == \"d_i\") %>%\n    select(estimate, p.value, conf.low, conf.high) %>% \n    # Is zero within the 95% confidence interval? \n    mutate(contains_truth = as.integer(between(params$tau,conf.low,conf.high)))\n\n  return(out)\n}\n\nparams %>% # Step 1: Parameterize the problem\n    dgp_df() %>%  # Step 2: Define the data generation process\n      estimator_fn() %>%  # Step 3: Estimate \n        disc_fn() # Step 4: Pull out what you need", 
            opts = list(label = "\"ci_steps4\"", exercise.setup = "\"ci_steps1to3\"", 
                echo = "TRUE", exercise = "TRUE", exercise.lines = "17L"), 
            engine = "r"), list(label = "ci_disc", code = "generate_estimate_discriminate <- function(params) {\n  params %>% # Step 1: Parameterize the problem\n      dgp_df() %>%  # Step 2: Define the data generation process\n        estimator_fn() %>%  # Step 3: Estimate \n          disc_fn() # Step 4: Pull out what you need\n}\n\nparams %>% \n  generate_estimate_discriminate()\n", 
            opts = list(label = "\"ci_disc\"", exercise.setup = "\"ci_steps4\"", 
                echo = "TRUE", exercise = "TRUE", exercise.lines = "10L"), 
            engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        label = "ci_disc", exercise.setup = "ci_steps4", exercise = TRUE, 
        exercise.lines = 10L, code = c("generate_estimate_discriminate <- function(params) {", 
        "  params %>% # Step 1: Parameterize the problem", "      dgp_df() %>%  # Step 2: Define the data generation process", 
        "        estimator_fn() %>%  # Step 3: Estimate ", "          disc_fn() # Step 4: Pull out what you need", 
        "}", "", "params %>% ", "  generate_estimate_discriminate()", 
        ""), out.width.px = 624, out.height.px = 384, params.src = "ci_disc, exercise.setup = \"ci_steps4\"", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "3"), class = "tutorial_exercise"))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-ci_mc-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-ci_mc-code-editor`)), session)
output$`tutorial-exercise-ci_mc-output` <- renderUI({
  `tutorial-exercise-ci_mc-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "ci_mc", global_setup = structure(c("# load packages", 
"library(learnr)", "library(gradethis)", "library(sortable)", 
"library(tidyverse)", "library(learnrhash) #devtools::install_github(\"rundel/learnrhash\")", 
"library(showtext)", "library(googlesheets4)", "library(mcreplicate)", 
"library(knitr)", "library(hrbrthemes)", "#devtools::install_github(\"graveja0/HPOL8539PKG\")", 
"#library(HPOL8539PKG)", "# devtools::load_all(\"../../HPOL8539PKG\")", 
"", "", "# don't echo chunks", "knitr::opts_chunk$set(echo = FALSE)", 
"", "# apply theme to ggplot", "ggplot2::theme_set(theme_bw())", 
"", "plot_sampling_distribution <- function(x,truth) {", "  d <- density(x)", 
"  p_df <- as_tibble(cbind(x = d$x, density = d$y))", "  p_df %>%", 
"    ggplot(aes(x = x, y = density)) + geom_line() +", "    #hrbrthemes::theme_ipsum() +", 
"    labs(x = \"Estimate\", y = \"Density\") +", "    geom_vline(aes(xintercept = truth)) +", 
"    annotate(\"text\",x = mean(x), y = min(d$y*1.2), vjust=-1,label  = glue::glue(\"  \\tMean: {formatC(mean(x),digits = 3, format='f')}\\n   SD: {formatC(sd(x),digits = 3, format = 'f')}\"), hjust = 0)", 
"}", "", "plot_cis <- function(x, K, truth) {", "  res <- x %>% bind_rows(.id = \"m\") %>%", 
"    as_tibble() %>%", "    mutate(m = factor(m)) %>%", "    mutate(m = fct_reorder(m,estimate, .desc = TRUE)) %>%", 
"    mutate(truth = truth) %>%", "    rowwise() %>%", "    mutate(covered = as.integer(between(truth,conf.low,conf.high))) %>%", 
"    ungroup() %>%", "    mutate(color = ifelse(covered ==1 , \"\",\"Rejected\"))", 
"  ", "  K = sample(res$m,100, replace =TRUE)", "  res %>%", 
"    filter(m %in% K) %>%", "    ggplot() +", "    geom_errorbar(aes(xmin =  conf.low, xmax = conf.high, y= m,colour = color)) +", 
"    #theme_ipsum() +", "    scale_y_discrete(breaks = NULL) +", 
"    geom_vline(aes(xintercept = truth)) +", "    labs(title= glue(\"Confidence Intervals for {prettyNum(length(K),big.mark=',')} of {prettyNum(length(res$m),big.mark=',')} Estimates\"),", 
"         y= \"Sampling Iteration\",x = \"Estimate\",", "         subtitle= glue(\"{formatC(100*mean(res$covered),digits = 1, format='f')}% of confidence intervals cover the truth\")) +", 
"    scale_colour_manual(values = c(\"black\",\"red\")) +", "    theme(legend.position = \"none\")", 
"}", "", ""), chunk_opts = list(label = "setup", include = FALSE)), 
    setup = "##################################\n# Step 1: Parameterize the Problem\n##################################\nparams =list(\n  N = 1000,\n  mean_x_i = 2,\n  sd_x_i = 0.5,\n  pr_Tx = 0.5,\n  beta = 1,\n  tau = 0.5,\n  sigma_sq_epsilon = 1\n)\n\n####################################################\n# Step 2: Define a Data Generation Process Function\n#####################################################\ndgp_df =function(params) {\n  with(params,{\n    df =\n      tibble(\n        x_i = rnorm(N, mean_x_i, sd_x_i),\n        d_i = rbinom(N, size = 1, prob = pr_Tx),\n        epsilon_i = rnorm(N, mean = 0, sd = sigma_sq_epsilon)\n      ) %>% \n      mutate(y_i = beta * x_i + tau * d_i + epsilon_i)\n    return(df)\n  })\n}\n\n############################################\n# 3. Define and Apply an Estimation Function\n#############################################\nestimator_fn = function(df) {\n  out =\n    df %>% \n      lm(y_i ~ x_i + d_i, data = .)\n  return(out)\n}\n\nfit = \n  params %>% # Step 1: Parameterize the problem\n    dgp_df() %>%  # Step 2: Define the data generation process\n    estimator_fn() # Step 3: Apply the estimator\nfit\n\n\ndisc_fn = function(fit) {\n  fit_ =broom::tidy(fit,conf.int = TRUE  )   \n  out <- \n    fit_ %>% \n    filter(term == \"d_i\") %>%\n    select(estimate, p.value, conf.low, conf.high) %>% \n    # Is zero within the 95% confidence interval? \n    mutate(contains_truth = as.integer(between(params$tau,conf.low,conf.high)))\n\n  return(out)\n}\n\nparams %>% # Step 1: Parameterize the problem\n    dgp_df() %>%  # Step 2: Define the data generation process\n      estimator_fn() %>%  # Step 3: Estimate \n        disc_fn() # Step 4: Pull out what you need\ngenerate_estimate_discriminate <- function(params) {\n  params %>% # Step 1: Parameterize the problem\n      dgp_df() %>%  # Step 2: Define the data generation process\n        estimator_fn() %>%  # Step 3: Estimate \n          disc_fn() # Step 4: Pull out what you need\n}\n\nparams %>% \n  generate_estimate_discriminate()\n", 
    chunks = list(list(label = "ci_steps1to3", code = "##################################\n# Step 1: Parameterize the Problem\n##################################\nparams =list(\n  N = 1000,\n  mean_x_i = 2,\n  sd_x_i = 0.5,\n  pr_Tx = 0.5,\n  beta = 1,\n  tau = 0.5,\n  sigma_sq_epsilon = 1\n)\n\n####################################################\n# Step 2: Define a Data Generation Process Function\n#####################################################\ndgp_df =function(params) {\n  with(params,{\n    df =\n      tibble(\n        x_i = rnorm(N, mean_x_i, sd_x_i),\n        d_i = rbinom(N, size = 1, prob = pr_Tx),\n        epsilon_i = rnorm(N, mean = 0, sd = sigma_sq_epsilon)\n      ) %>% \n      mutate(y_i = beta * x_i + tau * d_i + epsilon_i)\n    return(df)\n  })\n}\n\n############################################\n# 3. Define and Apply an Estimation Function\n#############################################\nestimator_fn = function(df) {\n  out =\n    df %>% \n      lm(y_i ~ x_i + d_i, data = .)\n  return(out)\n}\n\nfit = \n  params %>% # Step 1: Parameterize the problem\n    dgp_df() %>%  # Step 2: Define the data generation process\n    estimator_fn() # Step 3: Apply the estimator\nfit\n\n", 
        opts = list(label = "\"ci_steps1to3\"", echo = "TRUE", 
            exercise = "TRUE", exercise.lines = "47L"), engine = "r"), 
        list(label = "ci_steps4", code = "disc_fn = function(fit) {\n  fit_ =broom::tidy(fit,conf.int = TRUE  )   \n  out <- \n    fit_ %>% \n    filter(term == \"d_i\") %>%\n    select(estimate, p.value, conf.low, conf.high) %>% \n    # Is zero within the 95% confidence interval? \n    mutate(contains_truth = as.integer(between(params$tau,conf.low,conf.high)))\n\n  return(out)\n}\n\nparams %>% # Step 1: Parameterize the problem\n    dgp_df() %>%  # Step 2: Define the data generation process\n      estimator_fn() %>%  # Step 3: Estimate \n        disc_fn() # Step 4: Pull out what you need", 
            opts = list(label = "\"ci_steps4\"", exercise.setup = "\"ci_steps1to3\"", 
                echo = "TRUE", exercise = "TRUE", exercise.lines = "17L"), 
            engine = "r"), list(label = "ci_disc", code = "generate_estimate_discriminate <- function(params) {\n  params %>% # Step 1: Parameterize the problem\n      dgp_df() %>%  # Step 2: Define the data generation process\n        estimator_fn() %>%  # Step 3: Estimate \n          disc_fn() # Step 4: Pull out what you need\n}\n\nparams %>% \n  generate_estimate_discriminate()\n", 
            opts = list(label = "\"ci_disc\"", exercise.setup = "\"ci_steps4\"", 
                echo = "TRUE", exercise = "TRUE", exercise.lines = "10L"), 
            engine = "r"), list(label = "ci_mc", code = "\n# Monte Carlo simulation based on 1000 different realizations of the DGP:\nM = 1000\nmc_result <- 1:M %>% map_df(~generate_estimate_discriminate(params))\n\n# Take a peek at the output ...\nmc_result %>%\n  head() %>%\n  knitr::kable()\n", 
            opts = list(label = "\"ci_mc\"", exercise.setup = "\"ci_disc\"", 
                echo = "TRUE", exercise = "TRUE", exercise.lines = "10L"), 
            engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        label = "ci_mc", exercise.setup = "ci_disc", exercise = TRUE, 
        exercise.lines = 10L, code = c("", "# Monte Carlo simulation based on 1000 different realizations of the DGP:", 
        "M = 1000", "mc_result <- 1:M %>% map_df(~generate_estimate_discriminate(params))", 
        "", "# Take a peek at the output ...", "mc_result %>%", 
        "  head() %>%", "  knitr::kable()", ""), out.width.px = 624, 
        out.height.px = 384, params.src = "ci_mc, exercise.setup = \"ci_disc\"", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "3"), class = "tutorial_exercise"))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-ci_truth-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-ci_truth-code-editor`)), session)
output$`tutorial-exercise-ci_truth-output` <- renderUI({
  `tutorial-exercise-ci_truth-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "ci_truth", global_setup = structure(c("# load packages", 
"library(learnr)", "library(gradethis)", "library(sortable)", 
"library(tidyverse)", "library(learnrhash) #devtools::install_github(\"rundel/learnrhash\")", 
"library(showtext)", "library(googlesheets4)", "library(mcreplicate)", 
"library(knitr)", "library(hrbrthemes)", "#devtools::install_github(\"graveja0/HPOL8539PKG\")", 
"#library(HPOL8539PKG)", "# devtools::load_all(\"../../HPOL8539PKG\")", 
"", "", "# don't echo chunks", "knitr::opts_chunk$set(echo = FALSE)", 
"", "# apply theme to ggplot", "ggplot2::theme_set(theme_bw())", 
"", "plot_sampling_distribution <- function(x,truth) {", "  d <- density(x)", 
"  p_df <- as_tibble(cbind(x = d$x, density = d$y))", "  p_df %>%", 
"    ggplot(aes(x = x, y = density)) + geom_line() +", "    #hrbrthemes::theme_ipsum() +", 
"    labs(x = \"Estimate\", y = \"Density\") +", "    geom_vline(aes(xintercept = truth)) +", 
"    annotate(\"text\",x = mean(x), y = min(d$y*1.2), vjust=-1,label  = glue::glue(\"  \\tMean: {formatC(mean(x),digits = 3, format='f')}\\n   SD: {formatC(sd(x),digits = 3, format = 'f')}\"), hjust = 0)", 
"}", "", "plot_cis <- function(x, K, truth) {", "  res <- x %>% bind_rows(.id = \"m\") %>%", 
"    as_tibble() %>%", "    mutate(m = factor(m)) %>%", "    mutate(m = fct_reorder(m,estimate, .desc = TRUE)) %>%", 
"    mutate(truth = truth) %>%", "    rowwise() %>%", "    mutate(covered = as.integer(between(truth,conf.low,conf.high))) %>%", 
"    ungroup() %>%", "    mutate(color = ifelse(covered ==1 , \"\",\"Rejected\"))", 
"  ", "  K = sample(res$m,100, replace =TRUE)", "  res %>%", 
"    filter(m %in% K) %>%", "    ggplot() +", "    geom_errorbar(aes(xmin =  conf.low, xmax = conf.high, y= m,colour = color)) +", 
"    #theme_ipsum() +", "    scale_y_discrete(breaks = NULL) +", 
"    geom_vline(aes(xintercept = truth)) +", "    labs(title= glue(\"Confidence Intervals for {prettyNum(length(K),big.mark=',')} of {prettyNum(length(res$m),big.mark=',')} Estimates\"),", 
"         y= \"Sampling Iteration\",x = \"Estimate\",", "         subtitle= glue(\"{formatC(100*mean(res$covered),digits = 1, format='f')}% of confidence intervals cover the truth\")) +", 
"    scale_colour_manual(values = c(\"black\",\"red\")) +", "    theme(legend.position = \"none\")", 
"}", "", ""), chunk_opts = list(label = "setup", include = FALSE)), 
    setup = "##################################\n# Step 1: Parameterize the Problem\n##################################\nparams =list(\n  N = 1000,\n  mean_x_i = 2,\n  sd_x_i = 0.5,\n  pr_Tx = 0.5,\n  beta = 1,\n  tau = 0.5,\n  sigma_sq_epsilon = 1\n)\n\n####################################################\n# Step 2: Define a Data Generation Process Function\n#####################################################\ndgp_df =function(params) {\n  with(params,{\n    df =\n      tibble(\n        x_i = rnorm(N, mean_x_i, sd_x_i),\n        d_i = rbinom(N, size = 1, prob = pr_Tx),\n        epsilon_i = rnorm(N, mean = 0, sd = sigma_sq_epsilon)\n      ) %>% \n      mutate(y_i = beta * x_i + tau * d_i + epsilon_i)\n    return(df)\n  })\n}\n\n############################################\n# 3. Define and Apply an Estimation Function\n#############################################\nestimator_fn = function(df) {\n  out =\n    df %>% \n      lm(y_i ~ x_i + d_i, data = .)\n  return(out)\n}\n\nfit = \n  params %>% # Step 1: Parameterize the problem\n    dgp_df() %>%  # Step 2: Define the data generation process\n    estimator_fn() # Step 3: Apply the estimator\nfit\n\n\ndisc_fn = function(fit) {\n  fit_ =broom::tidy(fit,conf.int = TRUE  )   \n  out <- \n    fit_ %>% \n    filter(term == \"d_i\") %>%\n    select(estimate, p.value, conf.low, conf.high) %>% \n    # Is zero within the 95% confidence interval? \n    mutate(contains_truth = as.integer(between(params$tau,conf.low,conf.high)))\n\n  return(out)\n}\n\nparams %>% # Step 1: Parameterize the problem\n    dgp_df() %>%  # Step 2: Define the data generation process\n      estimator_fn() %>%  # Step 3: Estimate \n        disc_fn() # Step 4: Pull out what you need\ngenerate_estimate_discriminate <- function(params) {\n  params %>% # Step 1: Parameterize the problem\n      dgp_df() %>%  # Step 2: Define the data generation process\n        estimator_fn() %>%  # Step 3: Estimate \n          disc_fn() # Step 4: Pull out what you need\n}\n\nparams %>% \n  generate_estimate_discriminate()\n\n\n# Monte Carlo simulation based on 1000 different realizations of the DGP:\nM = 1000\nmc_result <- 1:M %>% map_df(~generate_estimate_discriminate(params))\n\n# Take a peek at the output ...\nmc_result %>%\n  head() %>%\n  knitr::kable()\n", 
    chunks = list(list(label = "ci_steps1to3", code = "##################################\n# Step 1: Parameterize the Problem\n##################################\nparams =list(\n  N = 1000,\n  mean_x_i = 2,\n  sd_x_i = 0.5,\n  pr_Tx = 0.5,\n  beta = 1,\n  tau = 0.5,\n  sigma_sq_epsilon = 1\n)\n\n####################################################\n# Step 2: Define a Data Generation Process Function\n#####################################################\ndgp_df =function(params) {\n  with(params,{\n    df =\n      tibble(\n        x_i = rnorm(N, mean_x_i, sd_x_i),\n        d_i = rbinom(N, size = 1, prob = pr_Tx),\n        epsilon_i = rnorm(N, mean = 0, sd = sigma_sq_epsilon)\n      ) %>% \n      mutate(y_i = beta * x_i + tau * d_i + epsilon_i)\n    return(df)\n  })\n}\n\n############################################\n# 3. Define and Apply an Estimation Function\n#############################################\nestimator_fn = function(df) {\n  out =\n    df %>% \n      lm(y_i ~ x_i + d_i, data = .)\n  return(out)\n}\n\nfit = \n  params %>% # Step 1: Parameterize the problem\n    dgp_df() %>%  # Step 2: Define the data generation process\n    estimator_fn() # Step 3: Apply the estimator\nfit\n\n", 
        opts = list(label = "\"ci_steps1to3\"", echo = "TRUE", 
            exercise = "TRUE", exercise.lines = "47L"), engine = "r"), 
        list(label = "ci_steps4", code = "disc_fn = function(fit) {\n  fit_ =broom::tidy(fit,conf.int = TRUE  )   \n  out <- \n    fit_ %>% \n    filter(term == \"d_i\") %>%\n    select(estimate, p.value, conf.low, conf.high) %>% \n    # Is zero within the 95% confidence interval? \n    mutate(contains_truth = as.integer(between(params$tau,conf.low,conf.high)))\n\n  return(out)\n}\n\nparams %>% # Step 1: Parameterize the problem\n    dgp_df() %>%  # Step 2: Define the data generation process\n      estimator_fn() %>%  # Step 3: Estimate \n        disc_fn() # Step 4: Pull out what you need", 
            opts = list(label = "\"ci_steps4\"", exercise.setup = "\"ci_steps1to3\"", 
                echo = "TRUE", exercise = "TRUE", exercise.lines = "17L"), 
            engine = "r"), list(label = "ci_disc", code = "generate_estimate_discriminate <- function(params) {\n  params %>% # Step 1: Parameterize the problem\n      dgp_df() %>%  # Step 2: Define the data generation process\n        estimator_fn() %>%  # Step 3: Estimate \n          disc_fn() # Step 4: Pull out what you need\n}\n\nparams %>% \n  generate_estimate_discriminate()\n", 
            opts = list(label = "\"ci_disc\"", exercise.setup = "\"ci_steps4\"", 
                echo = "TRUE", exercise = "TRUE", exercise.lines = "10L"), 
            engine = "r"), list(label = "ci_mc", code = "\n# Monte Carlo simulation based on 1000 different realizations of the DGP:\nM = 1000\nmc_result <- 1:M %>% map_df(~generate_estimate_discriminate(params))\n\n# Take a peek at the output ...\nmc_result %>%\n  head() %>%\n  knitr::kable()\n", 
            opts = list(label = "\"ci_mc\"", exercise.setup = "\"ci_disc\"", 
                echo = "TRUE", exercise = "TRUE", exercise.lines = "10L"), 
            engine = "r"), list(label = "ci_truth", code = "mc_result %>% \n  summarise(coverage = mean(contains_truth))\n", 
            opts = list(label = "\"ci_truth\"", exercise.setup = "\"ci_mc\"", 
                echo = "TRUE", exercise = "TRUE", exercise.lines = "10L"), 
            engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        label = "ci_truth", exercise.setup = "ci_mc", exercise = TRUE, 
        exercise.lines = 10L, code = c("mc_result %>% ", "  summarise(coverage = mean(contains_truth))", 
        ""), out.width.px = 624, out.height.px = 384, params.src = "ci_truth, exercise.setup = \"ci_mc\"", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "3"), class = "tutorial_exercise"))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-ci_plot-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-ci_plot-code-editor`)), session)
output$`tutorial-exercise-ci_plot-output` <- renderUI({
  `tutorial-exercise-ci_plot-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "ci_plot", global_setup = structure(c("# load packages", 
"library(learnr)", "library(gradethis)", "library(sortable)", 
"library(tidyverse)", "library(learnrhash) #devtools::install_github(\"rundel/learnrhash\")", 
"library(showtext)", "library(googlesheets4)", "library(mcreplicate)", 
"library(knitr)", "library(hrbrthemes)", "#devtools::install_github(\"graveja0/HPOL8539PKG\")", 
"#library(HPOL8539PKG)", "# devtools::load_all(\"../../HPOL8539PKG\")", 
"", "", "# don't echo chunks", "knitr::opts_chunk$set(echo = FALSE)", 
"", "# apply theme to ggplot", "ggplot2::theme_set(theme_bw())", 
"", "plot_sampling_distribution <- function(x,truth) {", "  d <- density(x)", 
"  p_df <- as_tibble(cbind(x = d$x, density = d$y))", "  p_df %>%", 
"    ggplot(aes(x = x, y = density)) + geom_line() +", "    #hrbrthemes::theme_ipsum() +", 
"    labs(x = \"Estimate\", y = \"Density\") +", "    geom_vline(aes(xintercept = truth)) +", 
"    annotate(\"text\",x = mean(x), y = min(d$y*1.2), vjust=-1,label  = glue::glue(\"  \\tMean: {formatC(mean(x),digits = 3, format='f')}\\n   SD: {formatC(sd(x),digits = 3, format = 'f')}\"), hjust = 0)", 
"}", "", "plot_cis <- function(x, K, truth) {", "  res <- x %>% bind_rows(.id = \"m\") %>%", 
"    as_tibble() %>%", "    mutate(m = factor(m)) %>%", "    mutate(m = fct_reorder(m,estimate, .desc = TRUE)) %>%", 
"    mutate(truth = truth) %>%", "    rowwise() %>%", "    mutate(covered = as.integer(between(truth,conf.low,conf.high))) %>%", 
"    ungroup() %>%", "    mutate(color = ifelse(covered ==1 , \"\",\"Rejected\"))", 
"  ", "  K = sample(res$m,100, replace =TRUE)", "  res %>%", 
"    filter(m %in% K) %>%", "    ggplot() +", "    geom_errorbar(aes(xmin =  conf.low, xmax = conf.high, y= m,colour = color)) +", 
"    #theme_ipsum() +", "    scale_y_discrete(breaks = NULL) +", 
"    geom_vline(aes(xintercept = truth)) +", "    labs(title= glue(\"Confidence Intervals for {prettyNum(length(K),big.mark=',')} of {prettyNum(length(res$m),big.mark=',')} Estimates\"),", 
"         y= \"Sampling Iteration\",x = \"Estimate\",", "         subtitle= glue(\"{formatC(100*mean(res$covered),digits = 1, format='f')}% of confidence intervals cover the truth\")) +", 
"    scale_colour_manual(values = c(\"black\",\"red\")) +", "    theme(legend.position = \"none\")", 
"}", "", ""), chunk_opts = list(label = "setup", include = FALSE)), 
    setup = "##################################\n# Step 1: Parameterize the Problem\n##################################\nparams =list(\n  N = 1000,\n  mean_x_i = 2,\n  sd_x_i = 0.5,\n  pr_Tx = 0.5,\n  beta = 1,\n  tau = 0.5,\n  sigma_sq_epsilon = 1\n)\n\n####################################################\n# Step 2: Define a Data Generation Process Function\n#####################################################\ndgp_df =function(params) {\n  with(params,{\n    df =\n      tibble(\n        x_i = rnorm(N, mean_x_i, sd_x_i),\n        d_i = rbinom(N, size = 1, prob = pr_Tx),\n        epsilon_i = rnorm(N, mean = 0, sd = sigma_sq_epsilon)\n      ) %>% \n      mutate(y_i = beta * x_i + tau * d_i + epsilon_i)\n    return(df)\n  })\n}\n\n############################################\n# 3. Define and Apply an Estimation Function\n#############################################\nestimator_fn = function(df) {\n  out =\n    df %>% \n      lm(y_i ~ x_i + d_i, data = .)\n  return(out)\n}\n\nfit = \n  params %>% # Step 1: Parameterize the problem\n    dgp_df() %>%  # Step 2: Define the data generation process\n    estimator_fn() # Step 3: Apply the estimator\nfit\n\n\ndisc_fn = function(fit) {\n  fit_ =broom::tidy(fit,conf.int = TRUE  )   \n  out <- \n    fit_ %>% \n    filter(term == \"d_i\") %>%\n    select(estimate, p.value, conf.low, conf.high) %>% \n    # Is zero within the 95% confidence interval? \n    mutate(contains_truth = as.integer(between(params$tau,conf.low,conf.high)))\n\n  return(out)\n}\n\nparams %>% # Step 1: Parameterize the problem\n    dgp_df() %>%  # Step 2: Define the data generation process\n      estimator_fn() %>%  # Step 3: Estimate \n        disc_fn() # Step 4: Pull out what you need\ngenerate_estimate_discriminate <- function(params) {\n  params %>% # Step 1: Parameterize the problem\n      dgp_df() %>%  # Step 2: Define the data generation process\n        estimator_fn() %>%  # Step 3: Estimate \n          disc_fn() # Step 4: Pull out what you need\n}\n\nparams %>% \n  generate_estimate_discriminate()\n\n\n# Monte Carlo simulation based on 1000 different realizations of the DGP:\nM = 1000\nmc_result <- 1:M %>% map_df(~generate_estimate_discriminate(params))\n\n# Take a peek at the output ...\nmc_result %>%\n  head() %>%\n  knitr::kable()\n", 
    chunks = list(list(label = "ci_steps1to3", code = "##################################\n# Step 1: Parameterize the Problem\n##################################\nparams =list(\n  N = 1000,\n  mean_x_i = 2,\n  sd_x_i = 0.5,\n  pr_Tx = 0.5,\n  beta = 1,\n  tau = 0.5,\n  sigma_sq_epsilon = 1\n)\n\n####################################################\n# Step 2: Define a Data Generation Process Function\n#####################################################\ndgp_df =function(params) {\n  with(params,{\n    df =\n      tibble(\n        x_i = rnorm(N, mean_x_i, sd_x_i),\n        d_i = rbinom(N, size = 1, prob = pr_Tx),\n        epsilon_i = rnorm(N, mean = 0, sd = sigma_sq_epsilon)\n      ) %>% \n      mutate(y_i = beta * x_i + tau * d_i + epsilon_i)\n    return(df)\n  })\n}\n\n############################################\n# 3. Define and Apply an Estimation Function\n#############################################\nestimator_fn = function(df) {\n  out =\n    df %>% \n      lm(y_i ~ x_i + d_i, data = .)\n  return(out)\n}\n\nfit = \n  params %>% # Step 1: Parameterize the problem\n    dgp_df() %>%  # Step 2: Define the data generation process\n    estimator_fn() # Step 3: Apply the estimator\nfit\n\n", 
        opts = list(label = "\"ci_steps1to3\"", echo = "TRUE", 
            exercise = "TRUE", exercise.lines = "47L"), engine = "r"), 
        list(label = "ci_steps4", code = "disc_fn = function(fit) {\n  fit_ =broom::tidy(fit,conf.int = TRUE  )   \n  out <- \n    fit_ %>% \n    filter(term == \"d_i\") %>%\n    select(estimate, p.value, conf.low, conf.high) %>% \n    # Is zero within the 95% confidence interval? \n    mutate(contains_truth = as.integer(between(params$tau,conf.low,conf.high)))\n\n  return(out)\n}\n\nparams %>% # Step 1: Parameterize the problem\n    dgp_df() %>%  # Step 2: Define the data generation process\n      estimator_fn() %>%  # Step 3: Estimate \n        disc_fn() # Step 4: Pull out what you need", 
            opts = list(label = "\"ci_steps4\"", exercise.setup = "\"ci_steps1to3\"", 
                echo = "TRUE", exercise = "TRUE", exercise.lines = "17L"), 
            engine = "r"), list(label = "ci_disc", code = "generate_estimate_discriminate <- function(params) {\n  params %>% # Step 1: Parameterize the problem\n      dgp_df() %>%  # Step 2: Define the data generation process\n        estimator_fn() %>%  # Step 3: Estimate \n          disc_fn() # Step 4: Pull out what you need\n}\n\nparams %>% \n  generate_estimate_discriminate()\n", 
            opts = list(label = "\"ci_disc\"", exercise.setup = "\"ci_steps4\"", 
                echo = "TRUE", exercise = "TRUE", exercise.lines = "10L"), 
            engine = "r"), list(label = "ci_mc", code = "\n# Monte Carlo simulation based on 1000 different realizations of the DGP:\nM = 1000\nmc_result <- 1:M %>% map_df(~generate_estimate_discriminate(params))\n\n# Take a peek at the output ...\nmc_result %>%\n  head() %>%\n  knitr::kable()\n", 
            opts = list(label = "\"ci_mc\"", exercise.setup = "\"ci_disc\"", 
                echo = "TRUE", exercise = "TRUE", exercise.lines = "10L"), 
            engine = "r"), list(label = "ci_plot", code = "# randomly sample 100 rows\nm_ <- sample(1:nrow(mc_result),100, replace = FALSE)\n\n# plot the CIs and color them based on whether or not they contain the truth \nmc_result %>% \n  filter(row_number() %in% m_) %>% \n  mutate(run = row_number()) %>% \n  ggplot() + \n  geom_errorbar(aes(xmin = conf.low, xmax = conf.high, y = run, colour = factor(contains_truth) )) +\n  #hrbrthemes::theme_ipsum(base_size=16) +\n  scale_y_discrete(breaks = NULL) +\n  geom_vline(aes(xintercept = params$tau)) +\n  labs(y=\"Monte Carlo Run\", x= \"\") + \n  theme(legend.position = \"none\") + \n  theme(axis.title.x = element_text(size=16)) + \n  theme(axis.title.y = element_text(size=16)) \n", 
            opts = list(label = "\"ci_plot\"", exercise.setup = "\"ci_mc\"", 
                echo = "TRUE", exercise = "TRUE", exercise.lines = "20L"), 
            engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        label = "ci_plot", exercise.setup = "ci_mc", exercise = TRUE, 
        exercise.lines = 20L, code = c("# randomly sample 100 rows", 
        "m_ <- sample(1:nrow(mc_result),100, replace = FALSE)", 
        "", "# plot the CIs and color them based on whether or not they contain the truth ", 
        "mc_result %>% ", "  filter(row_number() %in% m_) %>% ", 
        "  mutate(run = row_number()) %>% ", "  ggplot() + ", 
        "  geom_errorbar(aes(xmin = conf.low, xmax = conf.high, y = run, colour = factor(contains_truth) )) +", 
        "  #hrbrthemes::theme_ipsum(base_size=16) +", "  scale_y_discrete(breaks = NULL) +", 
        "  geom_vline(aes(xintercept = params$tau)) +", "  labs(y=\"Monte Carlo Run\", x= \"\") + ", 
        "  theme(legend.position = \"none\") + ", "  theme(axis.title.x = element_text(size=16)) + ", 
        "  theme(axis.title.y = element_text(size=16)) ", ""), 
        out.width.px = 624, out.height.px = 384, params.src = "ci_plot, exercise.setup = \"ci_mc\"", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "3"), class = "tutorial_exercise"))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-omb1-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-omb1-code-editor`)), session)
output$`tutorial-exercise-omb1-output` <- renderUI({
  `tutorial-exercise-omb1-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "omb1", global_setup = structure(c("# load packages", 
"library(learnr)", "library(gradethis)", "library(sortable)", 
"library(tidyverse)", "library(learnrhash) #devtools::install_github(\"rundel/learnrhash\")", 
"library(showtext)", "library(googlesheets4)", "library(mcreplicate)", 
"library(knitr)", "library(hrbrthemes)", "#devtools::install_github(\"graveja0/HPOL8539PKG\")", 
"#library(HPOL8539PKG)", "# devtools::load_all(\"../../HPOL8539PKG\")", 
"", "", "# don't echo chunks", "knitr::opts_chunk$set(echo = FALSE)", 
"", "# apply theme to ggplot", "ggplot2::theme_set(theme_bw())", 
"", "plot_sampling_distribution <- function(x,truth) {", "  d <- density(x)", 
"  p_df <- as_tibble(cbind(x = d$x, density = d$y))", "  p_df %>%", 
"    ggplot(aes(x = x, y = density)) + geom_line() +", "    #hrbrthemes::theme_ipsum() +", 
"    labs(x = \"Estimate\", y = \"Density\") +", "    geom_vline(aes(xintercept = truth)) +", 
"    annotate(\"text\",x = mean(x), y = min(d$y*1.2), vjust=-1,label  = glue::glue(\"  \\tMean: {formatC(mean(x),digits = 3, format='f')}\\n   SD: {formatC(sd(x),digits = 3, format = 'f')}\"), hjust = 0)", 
"}", "", "plot_cis <- function(x, K, truth) {", "  res <- x %>% bind_rows(.id = \"m\") %>%", 
"    as_tibble() %>%", "    mutate(m = factor(m)) %>%", "    mutate(m = fct_reorder(m,estimate, .desc = TRUE)) %>%", 
"    mutate(truth = truth) %>%", "    rowwise() %>%", "    mutate(covered = as.integer(between(truth,conf.low,conf.high))) %>%", 
"    ungroup() %>%", "    mutate(color = ifelse(covered ==1 , \"\",\"Rejected\"))", 
"  ", "  K = sample(res$m,100, replace =TRUE)", "  res %>%", 
"    filter(m %in% K) %>%", "    ggplot() +", "    geom_errorbar(aes(xmin =  conf.low, xmax = conf.high, y= m,colour = color)) +", 
"    #theme_ipsum() +", "    scale_y_discrete(breaks = NULL) +", 
"    geom_vline(aes(xintercept = truth)) +", "    labs(title= glue(\"Confidence Intervals for {prettyNum(length(K),big.mark=',')} of {prettyNum(length(res$m),big.mark=',')} Estimates\"),", 
"         y= \"Sampling Iteration\",x = \"Estimate\",", "         subtitle= glue(\"{formatC(100*mean(res$covered),digits = 1, format='f')}% of confidence intervals cover the truth\")) +", 
"    scale_colour_manual(values = c(\"black\",\"red\")) +", "    theme(legend.position = \"none\")", 
"}", "", ""), chunk_opts = list(label = "setup", include = FALSE)), 
    setup = NULL, chunks = list(list(label = "omb1", code = "##################################\n# Step 1: Parameterize the Problem\n##################################\nparams =list(\n  N = 1000,\n  mean_x_i = 2,\n  sd_x_i = 0.5,\n  beta = 1,\n  tau = 0.5,\n  sigma_sq_epsilon = 1\n)\n\n####################################################\n# Step 2: Define a Data Generation Process Function\n#####################################################\ndgp_df_ovb =function(params) {\n  with(params,{\n    df =\n      tibble(\n        # Covariate\n        x_i = rnorm(N, mean_x_i, sd_x_i),\n        # ADD UNOBSERVED HETEROGENEITY TERM\n        u_i = rnorm(N, mean = 0, sd = 1)) %>% \n        # Induce correlation between u_i and treatment;\n        # higher values of u_i make it more likely you're treated. \n        rowwise() %>% # This allows us to get each value's pr_treated in the line below. \n        mutate(pr_treated = boot::inv.logit(u_i)) %>% \n        ungroup() %>%  # This undoes the rowwise \n        # Treatment indicator\n        mutate(d_i = rbinom(N, size = 1, prob = pr_treated)) %>% \n        mutate(epsilon_i = rnorm(N, mean = 0, sd = sigma_sq_epsilon)) %>% \n        # u_i is also in the DGP for y_i \n        mutate(y_i = beta * x_i + tau * d_i + u_i + epsilon_i) %>% \n        # because u_i is unobserved, we strip it from the \"observed\" data output. \n        select(-u_i)\n    return(df)\n  })\n}\n\n############################################\n# 3. Define and Apply an Estimation Function\n#############################################\nestimator_fn = function(df) {\n  out =\n    df %>% \n      lm(y_i ~ x_i + d_i, data = .)\n  return(out)\n}\n\n########################################\n# 4. Define the discriminator function \n# (For this exercise we want to extract tau-hat \n# i.e., the coefficient on treated)\n########################################\ndisc_fn = function(fit) {\n  fit_ =broom::tidy(fit)   # This cleans up the fitted regression object\n  out =fit_ %>% \n    filter(term==\"d_i\") %>% \n    pull(estimate)\n  \n  return(out)\n}\n\n###############################################\n# 5. Define a compound function that executes\n# steps 1-4 based on the parameter inputs. \n###############################################\n\ngenerate_estimate_discriminate <- function(params) {\n  params %>% # Step 1: Parameterize the problem\n      dgp_df_ovb() %>%  # Step 2: Define the data generation process\n        estimator_fn() %>%  # Step 3: Estimate \n          disc_fn() %>% # Step 4: Pull out what you need\n            data.frame(tau_hat = .) # store the result as a data frame object\n}\n\n# Try it out\nparams %>% generate_estimate_discriminate(.)\n\n", 
        opts = list(label = "\"omb1\"", echo = "TRUE", exercise = "TRUE", 
            exercise.lines = "60L"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = NULL, solution = NULL, tests = NULL, 
    options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        label = "omb1", exercise = TRUE, exercise.lines = 60L, 
        code = c("##################################", "# Step 1: Parameterize the Problem", 
        "##################################", "params =list(", 
        "  N = 1000,", "  mean_x_i = 2,", "  sd_x_i = 0.5,", 
        "  beta = 1,", "  tau = 0.5,", "  sigma_sq_epsilon = 1", 
        ")", "", "####################################################", 
        "# Step 2: Define a Data Generation Process Function", 
        "#####################################################", 
        "dgp_df_ovb =function(params) {", "  with(params,{", 
        "    df =", "      tibble(", "        # Covariate", "        x_i = rnorm(N, mean_x_i, sd_x_i),", 
        "        # ADD UNOBSERVED HETEROGENEITY TERM", "        u_i = rnorm(N, mean = 0, sd = 1)) %>% ", 
        "        # Induce correlation between u_i and treatment;", 
        "        # higher values of u_i make it more likely you're treated. ", 
        "        rowwise() %>% # This allows us to get each value's pr_treated in the line below. ", 
        "        mutate(pr_treated = boot::inv.logit(u_i)) %>% ", 
        "        ungroup() %>%  # This undoes the rowwise ", 
        "        # Treatment indicator", "        mutate(d_i = rbinom(N, size = 1, prob = pr_treated)) %>% ", 
        "        mutate(epsilon_i = rnorm(N, mean = 0, sd = sigma_sq_epsilon)) %>% ", 
        "        # u_i is also in the DGP for y_i ", "        mutate(y_i = beta * x_i + tau * d_i + u_i + epsilon_i) %>% ", 
        "        # because u_i is unobserved, we strip it from the \"observed\" data output. ", 
        "        select(-u_i)", "    return(df)", "  })", "}", 
        "", "############################################", "# 3. Define and Apply an Estimation Function", 
        "#############################################", "estimator_fn = function(df) {", 
        "  out =", "    df %>% ", "      lm(y_i ~ x_i + d_i, data = .)", 
        "  return(out)", "}", "", "########################################", 
        "# 4. Define the discriminator function ", "# (For this exercise we want to extract tau-hat ", 
        "# i.e., the coefficient on treated)", "########################################", 
        "disc_fn = function(fit) {", "  fit_ =broom::tidy(fit)   # This cleans up the fitted regression object", 
        "  out =fit_ %>% ", "    filter(term==\"d_i\") %>% ", 
        "    pull(estimate)", "  ", "  return(out)", "}", "", 
        "###############################################", "# 5. Define a compound function that executes", 
        "# steps 1-4 based on the parameter inputs. ", "###############################################", 
        "", "generate_estimate_discriminate <- function(params) {", 
        "  params %>% # Step 1: Parameterize the problem", "      dgp_df_ovb() %>%  # Step 2: Define the data generation process", 
        "        estimator_fn() %>%  # Step 3: Estimate ", "          disc_fn() %>% # Step 4: Pull out what you need", 
        "            data.frame(tau_hat = .) # store the result as a data frame object", 
        "}", "", "# Try it out", "params %>% generate_estimate_discriminate(.)", 
        "", ""), out.width.px = 624, out.height.px = 384, params.src = "omb1", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "3"), class = "tutorial_exercise"))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-mc_ovb-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-mc_ovb-code-editor`)), session)
output$`tutorial-exercise-mc_ovb-output` <- renderUI({
  `tutorial-exercise-mc_ovb-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "mc_ovb", global_setup = structure(c("# load packages", 
"library(learnr)", "library(gradethis)", "library(sortable)", 
"library(tidyverse)", "library(learnrhash) #devtools::install_github(\"rundel/learnrhash\")", 
"library(showtext)", "library(googlesheets4)", "library(mcreplicate)", 
"library(knitr)", "library(hrbrthemes)", "#devtools::install_github(\"graveja0/HPOL8539PKG\")", 
"#library(HPOL8539PKG)", "# devtools::load_all(\"../../HPOL8539PKG\")", 
"", "", "# don't echo chunks", "knitr::opts_chunk$set(echo = FALSE)", 
"", "# apply theme to ggplot", "ggplot2::theme_set(theme_bw())", 
"", "plot_sampling_distribution <- function(x,truth) {", "  d <- density(x)", 
"  p_df <- as_tibble(cbind(x = d$x, density = d$y))", "  p_df %>%", 
"    ggplot(aes(x = x, y = density)) + geom_line() +", "    #hrbrthemes::theme_ipsum() +", 
"    labs(x = \"Estimate\", y = \"Density\") +", "    geom_vline(aes(xintercept = truth)) +", 
"    annotate(\"text\",x = mean(x), y = min(d$y*1.2), vjust=-1,label  = glue::glue(\"  \\tMean: {formatC(mean(x),digits = 3, format='f')}\\n   SD: {formatC(sd(x),digits = 3, format = 'f')}\"), hjust = 0)", 
"}", "", "plot_cis <- function(x, K, truth) {", "  res <- x %>% bind_rows(.id = \"m\") %>%", 
"    as_tibble() %>%", "    mutate(m = factor(m)) %>%", "    mutate(m = fct_reorder(m,estimate, .desc = TRUE)) %>%", 
"    mutate(truth = truth) %>%", "    rowwise() %>%", "    mutate(covered = as.integer(between(truth,conf.low,conf.high))) %>%", 
"    ungroup() %>%", "    mutate(color = ifelse(covered ==1 , \"\",\"Rejected\"))", 
"  ", "  K = sample(res$m,100, replace =TRUE)", "  res %>%", 
"    filter(m %in% K) %>%", "    ggplot() +", "    geom_errorbar(aes(xmin =  conf.low, xmax = conf.high, y= m,colour = color)) +", 
"    #theme_ipsum() +", "    scale_y_discrete(breaks = NULL) +", 
"    geom_vline(aes(xintercept = truth)) +", "    labs(title= glue(\"Confidence Intervals for {prettyNum(length(K),big.mark=',')} of {prettyNum(length(res$m),big.mark=',')} Estimates\"),", 
"         y= \"Sampling Iteration\",x = \"Estimate\",", "         subtitle= glue(\"{formatC(100*mean(res$covered),digits = 1, format='f')}% of confidence intervals cover the truth\")) +", 
"    scale_colour_manual(values = c(\"black\",\"red\")) +", "    theme(legend.position = \"none\")", 
"}", "", ""), chunk_opts = list(label = "setup", include = FALSE)), 
    setup = "##################################\n# Step 1: Parameterize the Problem\n##################################\nparams =list(\n  N = 1000,\n  mean_x_i = 2,\n  sd_x_i = 0.5,\n  beta = 1,\n  tau = 0.5,\n  sigma_sq_epsilon = 1\n)\n\n####################################################\n# Step 2: Define a Data Generation Process Function\n#####################################################\ndgp_df_ovb =function(params) {\n  with(params,{\n    df =\n      tibble(\n        # Covariate\n        x_i = rnorm(N, mean_x_i, sd_x_i),\n        # ADD UNOBSERVED HETEROGENEITY TERM\n        u_i = rnorm(N, mean = 0, sd = 1)) %>% \n        # Induce correlation between u_i and treatment;\n        # higher values of u_i make it more likely you're treated. \n        rowwise() %>% # This allows us to get each value's pr_treated in the line below. \n        mutate(pr_treated = boot::inv.logit(u_i)) %>% \n        ungroup() %>%  # This undoes the rowwise \n        # Treatment indicator\n        mutate(d_i = rbinom(N, size = 1, prob = pr_treated)) %>% \n        mutate(epsilon_i = rnorm(N, mean = 0, sd = sigma_sq_epsilon)) %>% \n        # u_i is also in the DGP for y_i \n        mutate(y_i = beta * x_i + tau * d_i + u_i + epsilon_i) %>% \n        # because u_i is unobserved, we strip it from the \"observed\" data output. \n        select(-u_i)\n    return(df)\n  })\n}\n\n############################################\n# 3. Define and Apply an Estimation Function\n#############################################\nestimator_fn = function(df) {\n  out =\n    df %>% \n      lm(y_i ~ x_i + d_i, data = .)\n  return(out)\n}\n\n########################################\n# 4. Define the discriminator function \n# (For this exercise we want to extract tau-hat \n# i.e., the coefficient on treated)\n########################################\ndisc_fn = function(fit) {\n  fit_ =broom::tidy(fit)   # This cleans up the fitted regression object\n  out =fit_ %>% \n    filter(term==\"d_i\") %>% \n    pull(estimate)\n  \n  return(out)\n}\n\n###############################################\n# 5. Define a compound function that executes\n# steps 1-4 based on the parameter inputs. \n###############################################\n\ngenerate_estimate_discriminate <- function(params) {\n  params %>% # Step 1: Parameterize the problem\n      dgp_df_ovb() %>%  # Step 2: Define the data generation process\n        estimator_fn() %>%  # Step 3: Estimate \n          disc_fn() %>% # Step 4: Pull out what you need\n            data.frame(tau_hat = .) # store the result as a data frame object\n}\n\n# Try it out\nparams %>% generate_estimate_discriminate(.)\n\n", 
    chunks = list(list(label = "omb1", code = "##################################\n# Step 1: Parameterize the Problem\n##################################\nparams =list(\n  N = 1000,\n  mean_x_i = 2,\n  sd_x_i = 0.5,\n  beta = 1,\n  tau = 0.5,\n  sigma_sq_epsilon = 1\n)\n\n####################################################\n# Step 2: Define a Data Generation Process Function\n#####################################################\ndgp_df_ovb =function(params) {\n  with(params,{\n    df =\n      tibble(\n        # Covariate\n        x_i = rnorm(N, mean_x_i, sd_x_i),\n        # ADD UNOBSERVED HETEROGENEITY TERM\n        u_i = rnorm(N, mean = 0, sd = 1)) %>% \n        # Induce correlation between u_i and treatment;\n        # higher values of u_i make it more likely you're treated. \n        rowwise() %>% # This allows us to get each value's pr_treated in the line below. \n        mutate(pr_treated = boot::inv.logit(u_i)) %>% \n        ungroup() %>%  # This undoes the rowwise \n        # Treatment indicator\n        mutate(d_i = rbinom(N, size = 1, prob = pr_treated)) %>% \n        mutate(epsilon_i = rnorm(N, mean = 0, sd = sigma_sq_epsilon)) %>% \n        # u_i is also in the DGP for y_i \n        mutate(y_i = beta * x_i + tau * d_i + u_i + epsilon_i) %>% \n        # because u_i is unobserved, we strip it from the \"observed\" data output. \n        select(-u_i)\n    return(df)\n  })\n}\n\n############################################\n# 3. Define and Apply an Estimation Function\n#############################################\nestimator_fn = function(df) {\n  out =\n    df %>% \n      lm(y_i ~ x_i + d_i, data = .)\n  return(out)\n}\n\n########################################\n# 4. Define the discriminator function \n# (For this exercise we want to extract tau-hat \n# i.e., the coefficient on treated)\n########################################\ndisc_fn = function(fit) {\n  fit_ =broom::tidy(fit)   # This cleans up the fitted regression object\n  out =fit_ %>% \n    filter(term==\"d_i\") %>% \n    pull(estimate)\n  \n  return(out)\n}\n\n###############################################\n# 5. Define a compound function that executes\n# steps 1-4 based on the parameter inputs. \n###############################################\n\ngenerate_estimate_discriminate <- function(params) {\n  params %>% # Step 1: Parameterize the problem\n      dgp_df_ovb() %>%  # Step 2: Define the data generation process\n        estimator_fn() %>%  # Step 3: Estimate \n          disc_fn() %>% # Step 4: Pull out what you need\n            data.frame(tau_hat = .) # store the result as a data frame object\n}\n\n# Try it out\nparams %>% generate_estimate_discriminate(.)\n\n", 
        opts = list(label = "\"omb1\"", echo = "TRUE", exercise = "TRUE", 
            exercise.lines = "60L"), engine = "r"), list(label = "mc_ovb", 
        code = "\n# Monte Carlo simulation based on 1000 different realizations of the DGP:\nM = 1000\nmc_result <- 1:M %>% map_df(~generate_estimate_discriminate(params))\n\n# Take a peek at the output ...\nmc_result %>%\n  head() \n", 
        opts = list(label = "\"mc_ovb\"", exercise.setup = "\"omb1\"", 
            echo = "TRUE", exercise = "TRUE", exercise.lines = "10L"), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        label = "mc_ovb", exercise.setup = "omb1", exercise = TRUE, 
        exercise.lines = 10L, code = c("", "# Monte Carlo simulation based on 1000 different realizations of the DGP:", 
        "M = 1000", "mc_result <- 1:M %>% map_df(~generate_estimate_discriminate(params))", 
        "", "# Take a peek at the output ...", "mc_result %>%", 
        "  head() ", ""), out.width.px = 624, out.height.px = 384, 
        params.src = "mc_ovb, exercise.setup = \"omb1\"", fig.num = 0, 
        exercise.df_print = "paged"), engine = "r", version = "3"), class = "tutorial_exercise"))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-mc_sd-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-mc_sd-code-editor`)), session)
output$`tutorial-exercise-mc_sd-output` <- renderUI({
  `tutorial-exercise-mc_sd-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "mc_sd", global_setup = structure(c("# load packages", 
"library(learnr)", "library(gradethis)", "library(sortable)", 
"library(tidyverse)", "library(learnrhash) #devtools::install_github(\"rundel/learnrhash\")", 
"library(showtext)", "library(googlesheets4)", "library(mcreplicate)", 
"library(knitr)", "library(hrbrthemes)", "#devtools::install_github(\"graveja0/HPOL8539PKG\")", 
"#library(HPOL8539PKG)", "# devtools::load_all(\"../../HPOL8539PKG\")", 
"", "", "# don't echo chunks", "knitr::opts_chunk$set(echo = FALSE)", 
"", "# apply theme to ggplot", "ggplot2::theme_set(theme_bw())", 
"", "plot_sampling_distribution <- function(x,truth) {", "  d <- density(x)", 
"  p_df <- as_tibble(cbind(x = d$x, density = d$y))", "  p_df %>%", 
"    ggplot(aes(x = x, y = density)) + geom_line() +", "    #hrbrthemes::theme_ipsum() +", 
"    labs(x = \"Estimate\", y = \"Density\") +", "    geom_vline(aes(xintercept = truth)) +", 
"    annotate(\"text\",x = mean(x), y = min(d$y*1.2), vjust=-1,label  = glue::glue(\"  \\tMean: {formatC(mean(x),digits = 3, format='f')}\\n   SD: {formatC(sd(x),digits = 3, format = 'f')}\"), hjust = 0)", 
"}", "", "plot_cis <- function(x, K, truth) {", "  res <- x %>% bind_rows(.id = \"m\") %>%", 
"    as_tibble() %>%", "    mutate(m = factor(m)) %>%", "    mutate(m = fct_reorder(m,estimate, .desc = TRUE)) %>%", 
"    mutate(truth = truth) %>%", "    rowwise() %>%", "    mutate(covered = as.integer(between(truth,conf.low,conf.high))) %>%", 
"    ungroup() %>%", "    mutate(color = ifelse(covered ==1 , \"\",\"Rejected\"))", 
"  ", "  K = sample(res$m,100, replace =TRUE)", "  res %>%", 
"    filter(m %in% K) %>%", "    ggplot() +", "    geom_errorbar(aes(xmin =  conf.low, xmax = conf.high, y= m,colour = color)) +", 
"    #theme_ipsum() +", "    scale_y_discrete(breaks = NULL) +", 
"    geom_vline(aes(xintercept = truth)) +", "    labs(title= glue(\"Confidence Intervals for {prettyNum(length(K),big.mark=',')} of {prettyNum(length(res$m),big.mark=',')} Estimates\"),", 
"         y= \"Sampling Iteration\",x = \"Estimate\",", "         subtitle= glue(\"{formatC(100*mean(res$covered),digits = 1, format='f')}% of confidence intervals cover the truth\")) +", 
"    scale_colour_manual(values = c(\"black\",\"red\")) +", "    theme(legend.position = \"none\")", 
"}", "", ""), chunk_opts = list(label = "setup", include = FALSE)), 
    setup = "##################################\n# Step 1: Parameterize the Problem\n##################################\nparams =list(\n  N = 1000,\n  mean_x_i = 2,\n  sd_x_i = 0.5,\n  beta = 1,\n  tau = 0.5,\n  sigma_sq_epsilon = 1\n)\n\n####################################################\n# Step 2: Define a Data Generation Process Function\n#####################################################\ndgp_df_ovb =function(params) {\n  with(params,{\n    df =\n      tibble(\n        # Covariate\n        x_i = rnorm(N, mean_x_i, sd_x_i),\n        # ADD UNOBSERVED HETEROGENEITY TERM\n        u_i = rnorm(N, mean = 0, sd = 1)) %>% \n        # Induce correlation between u_i and treatment;\n        # higher values of u_i make it more likely you're treated. \n        rowwise() %>% # This allows us to get each value's pr_treated in the line below. \n        mutate(pr_treated = boot::inv.logit(u_i)) %>% \n        ungroup() %>%  # This undoes the rowwise \n        # Treatment indicator\n        mutate(d_i = rbinom(N, size = 1, prob = pr_treated)) %>% \n        mutate(epsilon_i = rnorm(N, mean = 0, sd = sigma_sq_epsilon)) %>% \n        # u_i is also in the DGP for y_i \n        mutate(y_i = beta * x_i + tau * d_i + u_i + epsilon_i) %>% \n        # because u_i is unobserved, we strip it from the \"observed\" data output. \n        select(-u_i)\n    return(df)\n  })\n}\n\n############################################\n# 3. Define and Apply an Estimation Function\n#############################################\nestimator_fn = function(df) {\n  out =\n    df %>% \n      lm(y_i ~ x_i + d_i, data = .)\n  return(out)\n}\n\n########################################\n# 4. Define the discriminator function \n# (For this exercise we want to extract tau-hat \n# i.e., the coefficient on treated)\n########################################\ndisc_fn = function(fit) {\n  fit_ =broom::tidy(fit)   # This cleans up the fitted regression object\n  out =fit_ %>% \n    filter(term==\"d_i\") %>% \n    pull(estimate)\n  \n  return(out)\n}\n\n###############################################\n# 5. Define a compound function that executes\n# steps 1-4 based on the parameter inputs. \n###############################################\n\ngenerate_estimate_discriminate <- function(params) {\n  params %>% # Step 1: Parameterize the problem\n      dgp_df_ovb() %>%  # Step 2: Define the data generation process\n        estimator_fn() %>%  # Step 3: Estimate \n          disc_fn() %>% # Step 4: Pull out what you need\n            data.frame(tau_hat = .) # store the result as a data frame object\n}\n\n# Try it out\nparams %>% generate_estimate_discriminate(.)\n\n\n\n# Monte Carlo simulation based on 1000 different realizations of the DGP:\nM = 1000\nmc_result <- 1:M %>% map_df(~generate_estimate_discriminate(params))\n\n# Take a peek at the output ...\nmc_result %>%\n  head() \n", 
    chunks = list(list(label = "omb1", code = "##################################\n# Step 1: Parameterize the Problem\n##################################\nparams =list(\n  N = 1000,\n  mean_x_i = 2,\n  sd_x_i = 0.5,\n  beta = 1,\n  tau = 0.5,\n  sigma_sq_epsilon = 1\n)\n\n####################################################\n# Step 2: Define a Data Generation Process Function\n#####################################################\ndgp_df_ovb =function(params) {\n  with(params,{\n    df =\n      tibble(\n        # Covariate\n        x_i = rnorm(N, mean_x_i, sd_x_i),\n        # ADD UNOBSERVED HETEROGENEITY TERM\n        u_i = rnorm(N, mean = 0, sd = 1)) %>% \n        # Induce correlation between u_i and treatment;\n        # higher values of u_i make it more likely you're treated. \n        rowwise() %>% # This allows us to get each value's pr_treated in the line below. \n        mutate(pr_treated = boot::inv.logit(u_i)) %>% \n        ungroup() %>%  # This undoes the rowwise \n        # Treatment indicator\n        mutate(d_i = rbinom(N, size = 1, prob = pr_treated)) %>% \n        mutate(epsilon_i = rnorm(N, mean = 0, sd = sigma_sq_epsilon)) %>% \n        # u_i is also in the DGP for y_i \n        mutate(y_i = beta * x_i + tau * d_i + u_i + epsilon_i) %>% \n        # because u_i is unobserved, we strip it from the \"observed\" data output. \n        select(-u_i)\n    return(df)\n  })\n}\n\n############################################\n# 3. Define and Apply an Estimation Function\n#############################################\nestimator_fn = function(df) {\n  out =\n    df %>% \n      lm(y_i ~ x_i + d_i, data = .)\n  return(out)\n}\n\n########################################\n# 4. Define the discriminator function \n# (For this exercise we want to extract tau-hat \n# i.e., the coefficient on treated)\n########################################\ndisc_fn = function(fit) {\n  fit_ =broom::tidy(fit)   # This cleans up the fitted regression object\n  out =fit_ %>% \n    filter(term==\"d_i\") %>% \n    pull(estimate)\n  \n  return(out)\n}\n\n###############################################\n# 5. Define a compound function that executes\n# steps 1-4 based on the parameter inputs. \n###############################################\n\ngenerate_estimate_discriminate <- function(params) {\n  params %>% # Step 1: Parameterize the problem\n      dgp_df_ovb() %>%  # Step 2: Define the data generation process\n        estimator_fn() %>%  # Step 3: Estimate \n          disc_fn() %>% # Step 4: Pull out what you need\n            data.frame(tau_hat = .) # store the result as a data frame object\n}\n\n# Try it out\nparams %>% generate_estimate_discriminate(.)\n\n", 
        opts = list(label = "\"omb1\"", echo = "TRUE", exercise = "TRUE", 
            exercise.lines = "60L"), engine = "r"), list(label = "mc_ovb", 
        code = "\n# Monte Carlo simulation based on 1000 different realizations of the DGP:\nM = 1000\nmc_result <- 1:M %>% map_df(~generate_estimate_discriminate(params))\n\n# Take a peek at the output ...\nmc_result %>%\n  head() \n", 
        opts = list(label = "\"mc_ovb\"", exercise.setup = "\"omb1\"", 
            echo = "TRUE", exercise = "TRUE", exercise.lines = "10L"), 
        engine = "r"), list(label = "mc_sd", code = "plot_sampling_distribution(mc_result$tau_hat, truth = params$tau)", 
        opts = list(label = "\"mc_sd\"", exercise.setup = "\"mc_ovb\"", 
            echo = "TRUE", exercise = "TRUE", exercise.lines = "10L"), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = NULL, solution = NULL, tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "Simulation-as-a-Guide-for-Study-Design-and-Inference-_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = TRUE, error = FALSE, 
        message = TRUE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        label = "mc_sd", exercise.setup = "mc_ovb", exercise = TRUE, 
        exercise.lines = 10L, code = "plot_sampling_distribution(mc_result$tau_hat, truth = params$tau)", 
        out.width.px = 624, out.height.px = 384, params.src = "mc_sd, exercise.setup = \"mc_ovb\"", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "3"), class = "tutorial_exercise"))
</script>
</p>
<!--html_preserve-->
<script type="application/shiny-prerendered" data-context="dependencies">
{"type":"list","attributes":{},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["header-attrs"]},{"type":"character","attributes":{},"value":["2.16"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/pandoc"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["header-attrs.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.16"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["3.6.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/3.6.0"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery-3.6.0.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquerylib"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.1.4"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["bootstrap"]},{"type":"character","attributes":{},"value":["3.3.5"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/bootstrap"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["viewport"]}},"value":[{"type":"character","attributes":{},"value":["width=device-width, initial-scale=1"]}]},{"type":"character","attributes":{},"value":["js/bootstrap.min.js","shim/html5shiv.min.js","shim/respond.min.js"]},{"type":"character","attributes":{},"value":["css/cerulean.min.css"]},{"type":"character","attributes":{},"value":["<style>h1 {font-size: 34px;}\n       h1.title {font-size: 38px;}\n       h2 {font-size: 30px;}\n       h3 {font-size: 24px;}\n       h4 {font-size: 18px;}\n       h5 {font-size: 16px;}\n       h6 {font-size: 12px;}\n       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}\n       pre:not([class]) { background-color: white }<\/style>"]},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.16"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["pagedtable"]},{"type":"character","attributes":{},"value":["1.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/pagedtable-1.1"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/pagedtable.js"]},{"type":"character","attributes":{},"value":["css/pagedtable.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.16"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["highlightjs"]},{"type":"character","attributes":{},"value":["9.12.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/highlightjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["highlight.js"]},{"type":"character","attributes":{},"value":["textmate.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.16"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial"]},{"type":"character","attributes":{},"value":["0.10.5.9000"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial.js"]},{"type":"character","attributes":{},"value":["tutorial.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["i18n"]},{"type":"character","attributes":{},"value":["21.6.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/i18n"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["i18next.min.js","tutorial-i18n-init.js"]},{"type":"NULL"},{"type":"character","attributes":{},"value":["<script id=\"i18n-cstm-trns\" type=\"application/json\">{\"language\":\"en\",\"resources\":{\"en\":{\"translation\":{\"button\":{\"runcode\":\"Run Code\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Hint\",\"hint_plural\":\"Hints\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Next Hint\",\"hintprev\":\"Previous Hint\",\"solution\":\"Solution\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Copy to Clipboard\",\"startover\":\"Start Over\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Continue\",\"submitanswer\":\"Submit Answer\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Previous Topic\",\"nexttopic\":\"Next Topic\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Try Again\"},\"text\":{\"startover\":\"Start Over\",\"areyousure\":\"Are you sure you want to start over? (all exercise progress will be reset)\",\"youmustcomplete\":\"You must complete the\",\"exercise\":\"exercise\",\"exercise_plural\":\"exercises\",\"inthissection\":\"in this section before continuing.\",\"code\":\"Code\",\"enginecap\":\"{{engine}} $t(text.code)\",\"quiz\":\"Quiz\",\"blank\":\"blank\",\"blank_plural\":\"blanks\",\"exercisecontainsblank\":\"This exercise contains {{count}} $t(text.blank).\",\"pleasereplaceblank\":\"Please replace {{blank}} with valid code.\",\"unparsable\":\"It looks like this might not be valid R code. R cannot determine how to turn your text into a complete command. You may have forgotten to fill in a blank, to remove an underscore, to include a comma between arguments, or to close an opening <code>&quot;<\\/code>, <code>'<\\/code>, <code>(<\\/code> or <code>{<\\/code> with a matching <code>&quot;<\\/code>, <code>'<\\/code>, <code>)<\\/code> or <code>}<\\/code>.\\n\",\"unparsablequotes\":\"<p>It looks like your R code contains specially formatted quotation marks or &quot;curly&quot; quotes (<code>{{character}}<\\/code>) around character strings, making your code invalid. R requires character values to be contained in straight quotation marks (<code>&quot;<\\/code> or <code>'<\\/code>).<\\/p> {{code}} <p>Don't worry, this is a common source of errors when you copy code from another app that applies its own formatting to text. You can try replacing the code on that line with the following. There may be other places that need to be fixed, too.<\\/p> {{suggestion}}\\n\",\"unparsableunicode\":\"<p>It looks like your R code contains an unexpected special character (<code>{{character}}<\\/code>) that makes your code invalid.<\\/p> {{code}} <p>Sometimes your code may contain a special character that looks like a regular character, especially if you copy and paste the code from another app. Try deleting the special character from your code and retyping it manually.<\\/p>\\n\",\"unparsableunicodesuggestion\":\"<p>It looks like your R code contains an unexpected special character (<code>{{character}}<\\/code>) that makes your code invalid.<\\/p> {{code}} <p>Sometimes your code may contain a special character that looks like a regular character, especially if you copy and paste the code from another app. You can try replacing the code on that line with the following. There may be other places that need to be fixed, too.<\\/p> {{suggestion}}\\n\",\"and\":\"and\",\"or\":\"or\",\"listcomma\":\", \",\"oxfordcomma\":\",\"}}},\"fr\":{\"translation\":{\"button\":{\"runcode\":\"Lancer le Code\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Indication\",\"hint_plural\":\"Indications\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Indication Suivante\",\"hintprev\":\"Indication Précédente\",\"solution\":\"Solution\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Copier dans le Presse-papier\",\"startover\":\"Recommencer\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Continuer\",\"submitanswer\":\"Soumettre\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Chapitre Précédent\",\"nexttopic\":\"Chapitre Suivant\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Réessayer\"},\"text\":{\"startover\":\"Recommencer\",\"areyousure\":\"Êtes-vous certains de vouloir recommencer? (La progression sera remise à zéro)\",\"youmustcomplete\":\"Vous devez d'abord compléter\",\"exercise\":\"l'exercice\",\"exercise_plural\":\"des exercices\",\"inthissection\":\"de cette section avec de continuer.\",\"code\":\"Code\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Quiz\",\"and\":\"et\",\"or\":\"ou\",\"oxfordcomma\":\"\"}}},\"es\":{\"translation\":{\"button\":{\"runcode\":\"Ejecutar código\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Pista\",\"hint_plural\":\"Pistas\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Siguiente pista\",\"hintprev\":\"Pista anterior\",\"solution\":\"Solución\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Copiar al portapapeles\",\"startover\":\"Reiniciar\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Continuar\",\"submitanswer\":\"Enviar respuesta\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Tema anterior\",\"nexttopic\":\"Tema siguiente\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Volver a intentar\"},\"text\":{\"startover\":\"Reiniciar\",\"areyousure\":\"¿De verdad quieres empezar de nuevo? (todo el progreso del ejercicio se perderá)\",\"youmustcomplete\":\"Debes completar\",\"exercise\":\"el ejercicio\",\"exercise_plural\":\"los ejercicios\",\"inthissection\":\"en esta sección antes de continuar.\",\"code\":\"Código\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Cuestionario\",\"and\":\"y\",\"or\":\"o\",\"oxfordcomma\":\"\"}}},\"pt\":{\"translation\":{\"button\":{\"runcode\":\"Executar código\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Dica\",\"hint_plural\":\"Dicas\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Próxima dica\",\"hintprev\":\"Dica anterior\",\"solution\":\"Solução\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Copiar para a área de transferência\",\"startover\":\"Reiniciar\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Continuar\",\"submitanswer\":\"Enviar resposta\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Tópico anterior\",\"nexttopic\":\"Próximo tópico\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Tentar novamente\"},\"text\":{\"startover\":\"Reiniciar\",\"areyousure\":\"Tem certeza que deseja começar novamente? (todo o progresso feito será perdido)\",\"youmustcomplete\":\"Você deve completar\",\"exercise\":\"o exercício\",\"exercise_plural\":\"os exercícios\",\"inthissection\":\"nesta seção antes de continuar.\",\"code\":\"Código\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Quiz\",\"and\":\"e\",\"or\":\"ou\",\"oxfordcomma\":\"\"}}},\"tr\":{\"translation\":{\"button\":{\"runcode\":\"Çalıştırma Kodu\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Ipucu\",\"hint_plural\":\"İpuçları\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Sonraki İpucu\",\"hintprev\":\"Önceki İpucu\",\"solution\":\"Çözüm\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Pano'ya Kopyala\",\"startover\":\"Baştan Başlamak\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Devam et\",\"submitanswer\":\"Cevabı onayla\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Önceki Konu\",\"nexttopic\":\"Sonraki Konu\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Tekrar Deneyin\"},\"text\":{\"startover\":\"Baştan Başlamak\",\"areyousure\":\"Baştan başlamak istediğinizden emin misiniz? (tüm egzersiz ilerlemesi kaybolacak)\",\"youmustcomplete\":\"Tamamlamalısın\",\"exercise\":\"egzersiz\",\"exercise_plural\":\"egzersizler\",\"inthissection\":\"devam etmeden önce bu bölümde\",\"code\":\"Kod\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Sınav\",\"oxfordcomma\":\"\"}}},\"emo\":{\"translation\":{\"button\":{\"runcode\":\"🏃\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"💡\",\"hint_plural\":\"$t(button.hint)\",\"hinttitle\":\"$t(button.hint)\",\"solution\":\"🎯\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"📋\",\"startover\":\"⏮\",\"startovertitle\":\"Start Over\",\"continue\":\"✅\",\"submitanswer\":\"🆗\",\"submitanswertitle\":\"Submit Answer\",\"previoustopic\":\"⬅\",\"nexttopic\":\"➡\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"🔁\"},\"text\":{\"startover\":\"⏮\",\"areyousure\":\"🤔\",\"youmustcomplete\":\"⚠️ 👉 🧑‍💻\",\"exercise\":\"\",\"exercise_plural\":\"\",\"inthissection\":\"\",\"code\":\"💻\",\"enginecap\":\"$t(text.code) {{engine}}\",\"oxfordcomma\":\"\"}}},\"eu\":{\"translation\":{\"button\":{\"runcode\":\"Kodea egikaritu\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Laguntza\",\"hint_plural\":\"Laguntza\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Aurreko laguntza\",\"hintprev\":\"Hurrengo laguntza\",\"solution\":\"Ebazpena\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Arbelean kopiatu\",\"startover\":\"Berrabiarazi\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Jarraitu\",\"submitanswer\":\"Erantzuna bidali\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Aurreko atala\",\"nexttopic\":\"Hurrengo atala\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Berriro saiatu\"},\"text\":{\"startover\":\"Berrabiarazi\",\"areyousure\":\"Berriro hasi nahi duzu? (egindako lana galdu egingo da)\",\"youmustcomplete\":\"Aurrera egin baino lehen atal honetako\",\"exercise\":\"ariketa egin behar duzu.\",\"exercise_plural\":\"ariketak egin behar dituzu.\",\"inthissection\":\"\",\"code\":\"Kodea\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Galdetegia\",\"oxfordcomma\":\"\"}}},\"de\":{\"translation\":{\"button\":{\"runcode\":\"Code ausführen\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Tipp\",\"hint_plural\":\"Tipps\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Nächster Tipp\",\"hintprev\":\"Vorheriger Tipp\",\"solution\":\"Lösung\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"In die Zwischenablage kopieren\",\"startover\":\"Neustart\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Weiter\",\"submitanswer\":\"Antwort einreichen\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Vorheriges Kapitel\",\"nexttopic\":\"Nächstes Kapitel\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Nochmal versuchen\"},\"text\":{\"startover\":\"Neustart\",\"areyousure\":\"Bist du sicher, dass du neustarten willst? (der gesamte Lernfortschritt wird gelöscht)\",\"youmustcomplete\":\"Vervollstädinge\",\"exercise\":\"die Übung\",\"exercise_plural\":\"die Übungen\",\"inthissection\":\"in diesem Kapitel, bevor du fortfährst.\",\"code\":\"Code\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Quiz\",\"blank\":\"Lücke\",\"blank_plural\":\"Lücken\",\"pleasereplaceblank\":\"Bitte ersetze {{blank}} mit gültigem Code.\",\"unparsable\":\"Dies scheint kein gültiger R Code zu sein. R kann deinen Text nicht in einen gültigen Befehl übersetzen. Du hast vielleicht vergessen, die Lücke zu füllen, einen Unterstrich zu entfernen, ein Komma zwischen Argumente zu setzen oder ein eröffnendes <code>&quot;<\\/code>, <code>'<\\/code>, <code>(<\\/code> oder <code>{<\\/code> mit einem zugehörigen <code>&quot;<\\/code>, <code>'<\\/code>, <code>)<\\/code> oder <code>}<\\/code> zu schließen.\\n\",\"and\":\"und\",\"or\":\"oder\",\"listcomma\":\", \",\"oxfordcomma\":\",\"}}},\"ko\":{\"translation\":{\"button\":{\"runcode\":\"코드 실행\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"힌트\",\"hint_plural\":\"힌트들\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"다음 힌트\",\"hintprev\":\"이전 힌트\",\"solution\":\"솔루션\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"클립보드에 복사\",\"startover\":\"재학습\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"다음 학습으로\",\"submitanswer\":\"정답 제출\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"이전 토픽\",\"nexttopic\":\"다음 토픽\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"재시도\"},\"text\":{\"startover\":\"재학습\",\"areyousure\":\"다시 시작 하시겠습니까? (모든 예제의 진행 정보가 재설정됩니다)\",\"youmustcomplete\":\"당신은 완료해야 합니다\",\"exercise\":\"연습문제\",\"exercise_plural\":\"연습문제들\",\"inthissection\":\"이 섹션을 실행하기 전에\",\"code\":\"코드\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"퀴즈\",\"blank\":\"공백\",\"blank_plural\":\"공백들\",\"exercisecontainsblank\":\"이 연습문제에는 {{count}}개의 $t(text.blank)이 포함되어 있습니다.\",\"pleasereplaceblank\":\"{{blank}}를 유효한 코드로 바꾸십시오.\",\"unparsable\":\"이것은 유효한 R 코드가 아닐 수 있습니다. R은 텍스트를 완전한 명령으로 변환하는 방법을 결정할 수 없습니다. 당신은 공백이나 밑줄을 대체하여 채우기, 인수를 컴마로 구분하기, 또는 <code>&quot;<\\/code>, <code>'<\\/code>, <code>(<\\/code> , <code>{<\\/code>로 시작하는 구문을 닫는 <code>&quot;<\\/code>, <code>'<\\/code>, <code>)<\\/code>, <code>}<\\/code>을 잊었을 수도 있습니다.\\n\",\"and\":\"그리고\",\"or\":\"혹은\",\"listcomma\":\", \",\"oxfordcomma\":\"\"}}},\"zh\":{\"translation\":{\"button\":{\"runcode\":\"运行代码\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"提示\",\"hint_plural\":\"提示\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"下一个提示\",\"hintprev\":\"上一个提示\",\"solution\":\"答案\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"复制到剪切板\",\"startover\":\"重新开始\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"继续\",\"submitanswer\":\"提交答案\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"上一专题\",\"nexttopic\":\"下一专题\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"再试一次\"},\"text\":{\"startover\":\"重置\",\"areyousure\":\"你确定要重新开始吗? (所有当前进度将被重置)\",\"youmustcomplete\":\"你必须完成\",\"exercise\":\"练习\",\"exercise_plural\":\"练习\",\"inthissection\":\"在进行本节之前\",\"code\":\"代码\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"测试\",\"blank\":\"空\",\"blank_plural\":\"空\",\"exercisecontainsblank\":\"本练习包含{{count}}个$t(text.blank)\",\"pleasereplaceblank\":\"请在{{blank}}内填写恰当的代码\",\"unparsable\":\"这似乎不是有效的R代码。 R不知道如何将您的文本转换为完整的命令。 您是否忘了填空，忘了删除下划线，忘了在参数之间包含逗号，或者是忘了用<code>&quot;<\\/code>, <code>'<\\/code>, <code>)<\\/code>,<code>}<\\/code>来封闭<code>&quot;<\\/code>, <code>'<\\/code>, <code>(<\\/code>。 or <code>{<\\/code>。\\n\",\"unparsablequotes\":\"<p>您的R代码中似乎含有特殊格式的引号，或者弯引号(<code>{{character}}<\\/code>) 在字符串前后，在R中字符串应该被直引号(<code>&quot;<\\/code> 或者 <code>'<\\/code>)包裹。<\\/p> {{code}} <p>别担心，该错误经常在复制粘贴包含格式的代码时遇到， 您可以尝试将该行中的代码替换为以下代码，也许还有其他地方需要修改。<\\/p> {{suggestion}}\\n\",\"unparsableunicode\":\"<p>您的代码中似乎包含有异常字符(<code>{{character}}<\\/code>),导致代码无效。<\\/p> {{code}} <p>有时候你的代码可能含有看似正常字符的特殊字符，特别是当你复制粘贴其他来源代码的时候。 请试着删除这些特殊字符,重新输入<\\/p>\\n\",\"unparsableunicodesuggestion\":\"<p>您的代码中似乎包含有异常字符(<code>{{character}}<\\/code>),导致代码无效。<\\/p> {{code}} <p>有时候你的代码可能含有看似正常字符的特殊字符，特别是当你复制粘贴其他来源代码的时候。 请试着删除这些特殊字符,重新输入<\\/p>\\n\",\"and\":\"且\",\"or\":\"或\",\"listcomma\":\",\",\"oxfordcomma\":\",\"}}},\"pl\":{\"translation\":{\"button\":{\"runcode\":\"Uruchom kod\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Podpowiedź\",\"hint_plural\":\"Podpowiedzi\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Następna podpowiedź\",\"hintprev\":\"Poprzednia podpowiedź\",\"solution\":\"Rozwiązanie\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Kopiuj do schowka\",\"startover\":\"Zacznij od początku\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Kontynuuj\",\"submitanswer\":\"Wyślij\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Poprzednia sekcja\",\"nexttopic\":\"Następna sekcja\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Spróbuj ponownie\"},\"text\":{\"startover\":\"Zacznij od początku\",\"areyousure\":\"Czy na pewno chcesz zacząć od początku? (cały postęp w zadaniu zostanie utracony)\",\"youmustcomplete\":\"Musisz ukończyć\",\"exercise\":\"ćwiczenie\",\"exercise_plural\":\"ćwiczenia\",\"inthissection\":\"w tej sekcji przed kontynuowaniem\",\"code\":\"Kod\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Quiz\",\"blank\":\"luka\",\"blank_plural\":\"luk(i)\",\"exercisecontainsblank\":\"To ćwiczenie zawiera {{count}} $t(text.blank).\",\"pleasereplaceblank\":\"Proszę uzupełnić {{blank}} prawidłowym kodem.\",\"unparsable\":\"Wygląda na to, że może to nie być prawidłowy kod R. R nie jest w stanie przetworzyć Twojego tekstu na polecenie. Mogłeś(-aś) zapomnieć wypełnić luki, usunąć podkreślnik, umieścić przecinka między argumentami, lub zamknąć znak <code>&quot;<\\/code>, <code>'<\\/code>, <code>(<\\/code> lub <code>{<\\/code> odpowiadającym <code>&quot;<\\/code>, <code>'<\\/code>, <code>)<\\/code> lub <code>}<\\/code>.\\n\",\"unparsablequotes\":\"<p>Wygląda na to, że Twój kod zawiera szczególnie sformatowane cudzysłowy lub cudzysłowy typograficzne (<code>{{character}}<\\/code>) przy ciągach znaków, co sprawia, że kod jest niepoprawny. R wymaga cudzysłowów prostych (<code>&quot;<\\/code> albo <code>'<\\/code>).<\\/p> {{code}} <p>Nie martw się, to powszechne źródło błędów, gdy kopiuje się kod z innego programu, który sam formatuje teskt. Możesz spróbować zastąpić swój kod następującym kodem. Mogą być też inne miejsca, które wymagają poprawienia.<\\/p> {{suggestion}}\\n\",\"unparsableunicode\":\"<p>Wygląda na to, że Twój kod zawiera niespodziewany znak specjalny (<code>{{character}}<\\/code>), co sprawia, że kod jest niepoprawny.<\\/p> {{code}} <p>Czasami Twój kod może zawierać znak specjalny, który wygląda jak zwykły znak, zwłaszcza jeśli kopiujesz kod z innego programu. Spróbuj usunąć znak specjalny i wpisać do ponownie ręcznie.<\\/p>\\n\",\"unparsableunicodesuggestion\":\"<p>Wygląda na to, że Twój kod zawiera niespodziewany znak specjalny (<code>{{character}}<\\/code>), co sprawia, że kod jest niepoprawny.<\\/p> {{code}} <p>Czasami Twój kod może zawierać znak specjalny, który wygląda jak zwykły znak, zwłaszcza jeśli kopiujesz kod z innego programu. Możesz spróbować zastąpić swój kod następującym kodem. Mogą być też inne miejsca, które wymagają poprawienia.<\\/p> {{suggestion}}\\n\",\"and\":\"i\",\"or\":\"lub\",\"listcomma\":\", \",\"oxfordcomma\":\"\"}}}}}<\/script>"]},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial-format"]},{"type":"character","attributes":{},"value":["0.10.5.9000"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmarkdown/templates/tutorial/resources"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial-format.js"]},{"type":"character","attributes":{},"value":["tutorial-format.css","rstudio-theme.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["3.6.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/3.6.0"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery-3.6.0.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquerylib"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.1.4"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["navigation"]},{"type":"character","attributes":{},"value":["1.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/navigation-1.1"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tabsets.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.16"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["highlightjs"]},{"type":"character","attributes":{},"value":["9.12.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/highlightjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["highlight.js"]},{"type":"character","attributes":{},"value":["default.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.16"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["3.6.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/3.6.0"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery-3.6.0.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquerylib"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.1.4"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["font-awesome"]},{"type":"character","attributes":{},"value":["5.1.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/fontawesome"]}]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["css/all.css","css/v4-shims.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.16"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["bootbox"]},{"type":"character","attributes":{},"value":["5.5.2"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/bootbox"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["bootbox.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["idb-keyvalue"]},{"type":"character","attributes":{},"value":["3.2.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/idb-keyval"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["idb-keyval-iife-compat.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[false]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial"]},{"type":"character","attributes":{},"value":["0.10.5.9000"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial.js"]},{"type":"character","attributes":{},"value":["tutorial.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]}]}
</script>
<!--/html_preserve-->
<!--html_preserve-->
<script type="application/shiny-prerendered" data-context="execution_dependencies">
{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["packages"]}},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["packages","version"]},"class":{"type":"character","attributes":{},"value":["data.frame"]},"row.names":{"type":"integer","attributes":{},"value":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101]}},"value":[{"type":"character","attributes":{},"value":["assertthat","backports","base","broom","bslib","cachem","cellranger","checkmate","cli","colorspace","compiler","crayon","curl","datasets","DBI","dbplyr","digest","dplyr","ellipsis","evaluate","extrafont","extrafontdb","fansi","fastmap","forcats","fs","gargle","gdtools","generics","ggplot2","glue","googledrive","googlesheets4","gradethis","graphics","grDevices","grid","gtable","haven","hms","hrbrthemes","htmltools","htmlwidgets","httpuv","httr","jquerylib","jsonlite","knitr","later","learnr","learnrhash","lifecycle","lubridate","magrittr","markdown","mcreplicate","methods","mime","modelr","munsell","parallel","pillar","pkgconfig","promises","purrr","R6","Rcpp","readr","readxl","reprex","rlang","rmarkdown","rprojroot","rstudioapi","Rttf2pt1","rvest","sass","scales","shiny","showtext","showtextdb","sortable","stats","stringi","stringr","sysfonts","systemfonts","tibble","tidyr","tidyselect","tidyverse","tools","tzdb","utf8","utils","vctrs","withr","xfun","xml2","xtable","yaml"]},{"type":"character","attributes":{},"value":["0.2.1","1.4.1","4.2.1","1.0.0","0.4.0","1.0.6","1.1.0","2.1.0","3.3.0","2.0-3","4.2.1","1.5.1","4.3.2","4.2.1","1.1.3","2.2.1","0.6.29","1.0.9","0.3.2","0.16","0.18","1.0","1.0.3","1.1.0","0.5.2","1.5.2","1.2.0","0.2.4","0.1.3","3.3.6","1.6.2","2.0.0","1.0.1","0.2.8.9000","4.2.1","4.2.1","4.2.1","0.3.0","2.5.1","1.1.2","0.8.0","0.5.3","1.5.4","1.6.5","1.4.4","0.1.4","1.8.0","1.40","1.3.0","0.10.5.9000","0.2.0","1.0.1","1.8.0","2.0.3","1.1","0.1.2","4.2.1","0.12","0.1.9","0.5.0","4.2.1","1.8.1","2.0.3","1.2.0.1","0.3.4","2.5.1","1.0.9","2.1.2","1.4.1","2.0.2","1.0.4","2.16","2.0.3","0.14","1.3.10","1.0.3","0.4.2","1.2.1","1.7.2","0.9-5","3.0","0.4.6","4.2.1","1.7.8","1.4.1","0.8.8","1.0.4","3.1.8","1.2.0","1.1.2","1.3.2","4.2.1","0.3.0","1.2.2","4.2.1","0.4.1","2.5.0","0.32","1.3.3","1.8-4","2.3.5"]}]}]}
</script>
<!--/html_preserve-->
</div>

</article> <!-- topics -->

<div class="topicsContainer">
<div class="topicsPositioner">
<div class="band">
<div class="bandContent topicsListContainer">

<!-- begin doc-metadata -->
<div id="doc-metadata">
<h1 class="title toc-ignore" style="display:none;">Simulation as a Guide
for Study Design and Inference</h1>
<h2 class="subtitle"><em>HPOL8539</em></h2>
</div>
<!-- end doc-metadata -->

</div> <!-- bandContent.topicsListContainer -->
</div> <!-- band -->
</div> <!-- topicsPositioner -->
</div> <!-- topicsContainer -->


</main> <!-- bandContent page -->
</div> <!-- pageContent band -->



<!-- Build Tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("section-TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<script>
// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});
</script>


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>


</body>

</html>
